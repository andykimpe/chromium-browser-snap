Description: implement EHABI Exception Handling for armhf
Origin: https://anonscm.debian.org/viewvc/pkg-llvm/libcxx/trunk/debian/patches/libcxxabi-arm-ehabi-fix.patch
Bug-Ubuntu: https://launchpad.net/bugs/1768653

--- a/buildtools/third_party/libc++abi/trunk/src/cxa_exception.cpp
+++ b/buildtools/third_party/libc++abi/trunk/src/cxa_exception.cpp
@@ -261,8 +261,10 @@ __cxa_throw(void *thrown_object, std::ty
 
 #ifdef __USING_SJLJ_EXCEPTIONS__
     _Unwind_SjLj_RaiseException(&exception_header->unwindHeader);
-#else
+#elif !defined(_LIBCXXABI_ARM_EHABI)
     _Unwind_RaiseException(&exception_header->unwindHeader);
+#else
+    _Unwind_RaiseException(exception_header->unwindHeader);
 #endif
     //  This only happens when there is no handler, or some unexpected unwinding
     //     error happens.
@@ -532,7 +534,11 @@ void __cxa_end_catch() {
             //    to touch a foreign exception in any way, that is undefined
             //     behavior.  They likely can't since the only way to catch
             //     a foreign exception is with catch (...)!
+#if !defined(_LIBCXXABI_ARM_EHABI)
             _Unwind_DeleteException(&globals->caughtExceptions->unwindHeader);
+#else
+            _Unwind_DeleteException(globals->caughtExceptions->unwindHeader);
+#endif
             globals->caughtExceptions = 0;
         }
     }
@@ -589,8 +595,10 @@ void __cxa_rethrow() {
     }
 #ifdef __USING_SJLJ_EXCEPTIONS__
     _Unwind_SjLj_RaiseException(&exception_header->unwindHeader);
-#else
+#elif !defined(_LIBCXXABI_ARM_EHABI)
     _Unwind_RaiseException(&exception_header->unwindHeader);
+#else
+    _Unwind_RaiseException(exception_header->unwindHeader);
 #endif
 
     //  If we get here, some kind of unwinding error has occurred.
@@ -714,8 +722,10 @@ __cxa_rethrow_primary_exception(void* th
         dep_exception_header->unwindHeader.exception_cleanup = dependent_exception_cleanup;
 #ifdef __USING_SJLJ_EXCEPTIONS__
         _Unwind_SjLj_RaiseException(&dep_exception_header->unwindHeader);
-#else
+#elif !defined(_LIBCXXABI_ARM_EHABI)
         _Unwind_RaiseException(&dep_exception_header->unwindHeader);
+#else
+        _Unwind_RaiseException(dep_exception_header->unwindHeader);
 #endif
         // Some sort of unwinding error.  Note that terminate is a handler.
         __cxa_begin_catch(&dep_exception_header->unwindHeader);
--- a/buildtools/third_party/libc++abi/trunk/src/cxa_exception.hpp
+++ b/buildtools/third_party/libc++abi/trunk/src/cxa_exception.hpp
@@ -24,6 +24,45 @@ static const uint64_t kOurExceptionClass
 static const uint64_t kOurDependentExceptionClass = 0x434C4E47432B2B01; // CLNGC++\1
 static const uint64_t get_vendor_and_language     = 0xFFFFFFFFFFFFFF00; // mask for CLNGC++
 
+#if defined(_LIBCXXABI_ARM_EHABI)
+// GCC has _Unwind_Control_Block in unwind.h (unwind_arm_common.h)
+#if defined(__clang__)
+struct _Unwind_Control_Block
+{
+   uint64_t exception_class;
+   void (*exception_cleanup)(_Unwind_Reason_Code, _Unwind_Control_Block *);
+   struct {
+       _Unwind_Word reserved1;
+       _Unwind_Word reserved2;
+       _Unwind_Word reserved3;
+       _Unwind_Word reserved4;
+       _Unwind_Word reserved5;
+   } unwinder_cache;
+   struct {
+       _Unwind_Word sp;
+       _Unwind_Word bitpattern[5];
+   } barrier_cache;
+   struct {
+       _Unwind_Word bitpattern[4];
+   } cleanup_cache;
+   struct {
+       _Unwind_Word fnstart;
+       _Unwind_Word *ehtp;
+       _Unwind_Word additional;
+       _Unwind_Word reserved1;
+   } pr_cache;
+   long long int :0;
+   operator _Unwind_Exception*() noexcept
+   {
+       return reinterpret_cast<_Unwind_Exception*>(this);
+   }
+};
+
+#endif
+
+#define _Unwind_Exception _Unwind_Control_Block
+#endif
+
 struct _LIBCXXABI_HIDDEN __cxa_exception {
 #if defined(__LP64__) || defined(_LIBCXXABI_ARM_EHABI)
     // This is a new field to support C++ 0x exception_ptr.
