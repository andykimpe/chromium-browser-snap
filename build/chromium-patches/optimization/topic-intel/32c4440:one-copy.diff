From 32c44405952fea732fd779935a2cf40bbfd44d07 Mon Sep 17 00:00:00 2001
From: Yaowei Zhou <yaowei.zhou@intel.com>
Date: Mon, 26 Jun 2023 10:37:35 +0800
Subject: [PATCH] [Duplicate] Add the one-copy for Linux* video capture

Duplicate the "Add one-copy for Linux* video capture" before upstream
done.

Bug: N/A
Change-Id: Idfe932f495dd717954b596ef5c49981de510e382
---

diff --git a/content/browser/utility_process_host.cc b/content/browser/utility_process_host.cc
index 4a5df7b..5515ff52 100644
--- a/content/browser/utility_process_host.cc
+++ b/content/browser/utility_process_host.cc
@@ -429,8 +429,7 @@
       file_data_->files_to_preload[kNetworkContextParentDirsDescriptor] =
           PassNetworkContextParentDirs(std::move(network_context_parent_dirs));
     }
-#endif  // BUILDFLAG(IS_LINUX)
-
+#endif
 #if BUILDFLAG(IS_LINUX)
     if (metrics_name_ == video_capture::mojom::VideoCaptureService::Name_) {
       if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
diff --git a/media/capture/BUILD.gn b/media/capture/BUILD.gn
index e39e96f..9d63fadc 100644
--- a/media/capture/BUILD.gn
+++ b/media/capture/BUILD.gn
@@ -272,6 +272,10 @@
 
   if (is_linux) {
     sources += [
+      "video/linux/v4l2_capture_delegate_gpu_helper.cc",
+      "video/linux/v4l2_capture_delegate_gpu_helper.h",
+      "video/linux/v4l2_gpu_memory_buffer_factory.cc",
+      "video/linux/v4l2_gpu_memory_buffer_factory.h",
       "video/linux/v4l2_gpu_memory_buffer_tracker.cc",
       "video/linux/v4l2_gpu_memory_buffer_tracker.h",
       "video/linux/video_capture_gpu_memory_buffer_manager.cc",
diff --git a/media/capture/video/linux/v4l2_capture_delegate.cc b/media/capture/video/linux/v4l2_capture_delegate.cc
index 8b9c581..bbe8d2f4 100644
--- a/media/capture/video/linux/v4l2_capture_delegate.cc
+++ b/media/capture/video/linux/v4l2_capture_delegate.cc
@@ -22,8 +22,10 @@
 #include "build/build_config.h"
 #include "media/base/video_frame.h"
 #include "media/base/video_types.h"
+#include "media/capture/capture_switches.h"
 #include "media/capture/mojom/image_capture_types.h"
 #include "media/capture/video/blob_utils.h"
+#include "media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h"
 #include "media/capture/video/linux/video_capture_device_linux.h"
 
 using media::mojom::MeteringMode;
@@ -310,7 +312,12 @@
       device_fd_(v4l2),
       is_capturing_(false),
       timeout_count_(0),
-      rotation_(rotation) {}
+      rotation_(rotation),
+      use_gpu_buffer_(switches::IsVideoCaptureUseGpuMemoryBufferEnabled()) {
+  if (use_gpu_buffer_) {
+    v4l2_gpu_helper_ = std::make_unique<V4L2CaptureDelegateGpuHelper>(this);
+  }
+}
 
 void V4L2CaptureDelegate::AllocateAndStart(
     int width,
@@ -428,7 +435,6 @@
                                      video_fmt_.fmt.pix.height);
   capture_format_.frame_rate = frame_rate;
   capture_format_.pixel_format = pixel_format;
-
   if (!StartStream())
     return;
 
@@ -1126,10 +1132,17 @@
       // matrix = v4l2_format->fmt.pix.ycbcr_enc;
       // transfer = v4l2_format->fmt.pix.xfer_func;
       // See http://crbug.com/959919.
-      client_->OnIncomingCapturedData(
-          buffer_tracker->start(), buffer_tracker->payload_size(),
-          capture_format_, gfx::ColorSpace(), rotation_, false /* flip_y */,
-          now, timestamp);
+      if (use_gpu_buffer_) {
+        v4l2_gpu_helper_->OnIncomingCapturedData(
+            buffer_tracker->start(), buffer_tracker->payload_size(),
+            capture_format_, gfx::ColorSpace(), rotation_, false /* flip_y */,
+            now, timestamp);
+      } else {
+        client_->OnIncomingCapturedData(
+            buffer_tracker->start(), buffer_tracker->payload_size(),
+            capture_format_, gfx::ColorSpace(), rotation_, false /* flip_y */,
+            now, timestamp);
+      }
     }
 
     while (!take_photo_callbacks_.empty()) {
diff --git a/media/capture/video/linux/v4l2_capture_delegate.h b/media/capture/video/linux/v4l2_capture_delegate.h
index e41d45fa..a21b869 100644
--- a/media/capture/video/linux/v4l2_capture_delegate.h
+++ b/media/capture/video/linux/v4l2_capture_delegate.h
@@ -149,6 +149,12 @@
   // Clockwise rotation in degrees. This value should be 0, 90, 180, or 270.
   int rotation_;
 
+  // support gpu buffer
+  class V4L2CaptureDelegateGpuHelper;
+  friend class V4L2CaptureDelegateGpuHelper;
+  bool use_gpu_buffer_;
+  std::unique_ptr<V4L2CaptureDelegateGpuHelper> v4l2_gpu_helper_;
+
   base::WeakPtrFactory<V4L2CaptureDelegate> weak_factory_{this};
 };
 
diff --git a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.cc b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.cc
new file mode 100644
index 0000000..43fb048
--- /dev/null
+++ b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.cc
@@ -0,0 +1,279 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h"
+
+#include "base/trace_event/trace_event.h"
+#include "third_party/libyuv/include/libyuv.h"
+#include "ui/gfx/gpu_memory_buffer.h"
+
+namespace media {
+
+namespace {
+constexpr media::VideoPixelFormat TARGET_PIXEL_FORMAT =
+    media::VideoPixelFormat::PIXEL_FORMAT_NV12;
+constexpr gfx::BufferFormat TARGET_BUFFER_FORMAT =
+    gfx::BufferFormat::YUV_420_BIPLANAR;
+}  // namespace
+
+libyuv::FourCC ViedoCaptureFormatToLibyuvFourcc(
+    const VideoCaptureFormat& capture_format) {
+  const int chopped_width = capture_format.frame_size.width() & 1;
+  const int chopped_height = capture_format.frame_size.height() & 1;
+
+  switch (capture_format.pixel_format) {
+    case PIXEL_FORMAT_NV12:
+      DCHECK(!chopped_width && !chopped_height);
+      return libyuv::FOURCC_NV12;
+    case PIXEL_FORMAT_YUY2:
+      DCHECK(!chopped_width && !chopped_height);
+      return libyuv::FOURCC_YUY2;
+    case PIXEL_FORMAT_MJPEG:
+      return libyuv::FOURCC_MJPG;
+    default:
+      NOTREACHED();
+  }
+  return libyuv::FOURCC_ANY;
+}
+
+libyuv::RotationMode TranslateRotation(int rotation_degrees) {
+  DCHECK_EQ(0, rotation_degrees % 90) << " Rotation must be a multiple of 90, "
+                                         "now: "
+                                      << rotation_degrees;
+  libyuv::RotationMode rotation_mode = libyuv::kRotate0;
+  if (rotation_degrees == 90) {
+    rotation_mode = libyuv::kRotate90;
+  } else if (rotation_degrees == 180) {
+    rotation_mode = libyuv::kRotate180;
+  } else if (rotation_degrees == 270) {
+    rotation_mode = libyuv::kRotate270;
+  }
+  return rotation_mode;
+}
+
+V4L2CaptureDelegate::V4L2CaptureDelegateGpuHelper::V4L2CaptureDelegateGpuHelper(
+    V4L2CaptureDelegate* v4l2_capture_delegate)
+    : v4l2_delegate_(v4l2_capture_delegate) {
+  LOG(WARNING) << "Enable GPU memory buffer for video capture!";
+  LOG(WARNING) << "Video capture works under the one-copy mode!";
+}
+
+V4L2CaptureDelegate ::V4L2CaptureDelegateGpuHelper::
+    ~V4L2CaptureDelegateGpuHelper() = default;
+
+int V4L2CaptureDelegate::V4L2CaptureDelegateGpuHelper::OnIncomingCapturedData(
+    const uint8_t* sample,
+    size_t sample_size,
+    const VideoCaptureFormat& capture_format,
+    const gfx::ColorSpace& data_color_space,
+    int rotation,
+    bool flip_y,
+    base::TimeTicks reference_time,
+    base::TimeDelta timestamp,
+    int frame_feedback_id) {
+  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("video_and_image_capture"),
+               "V4L2CaptureDelegateGpuHelper::OnIncomingCapturedData");
+  if (!v4l2_delegate_ || !v4l2_delegate_->client_.get()) {
+    return -1;
+  }
+  VideoCaptureDevice::Client* client = v4l2_delegate_->client_.get();
+
+  int dst_width = capture_format.frame_size.width() & ~1;
+  int dst_height = capture_format.frame_size.height() & ~1;
+  if (rotation == 90 || rotation == 270) {
+    std::swap(dst_width, dst_height);
+  }
+  const gfx::Size dimensions(dst_width, dst_height);
+
+  VideoCaptureDevice::Client::Buffer capture_buffer;
+  auto reservation_result_code = client->ReserveOutputBuffer(
+      dimensions, TARGET_PIXEL_FORMAT, frame_feedback_id, &capture_buffer);
+  if (reservation_result_code !=
+      VideoCaptureDevice::Client::ReserveResult::kSucceeded) {
+    DLOG(ERROR) << "Failed to reserve output capture buffer: "
+                << (int)reservation_result_code;
+    client->OnFrameDropped(
+        ConvertReservationFailureToFrameDropReason(reservation_result_code));
+    return -1;
+  }
+
+  std::unique_ptr<gfx::GpuMemoryBuffer> client_gpu_memory_buff =
+      gmb_support_.CreateGpuMemoryBufferImplFromHandle(
+          capture_buffer.handle_provider->GetGpuMemoryBufferHandle(),
+          dimensions, TARGET_BUFFER_FORMAT,
+          gfx::BufferUsage::GPU_READ_CPU_READ_WRITE, base::NullCallback());
+  if (!client_gpu_memory_buff) {
+    DLOG(ERROR) << "Failed to allocate gpu memory buffer buffer";
+    client->OnFrameDropped(ConvertReservationFailureToFrameDropReason(
+        VideoCaptureDevice::Client::ReserveResult::kAllocationFailed));
+    return -1;
+  }
+  int status = CovertCaptureDataToNV12(sample, sample_size, capture_format,
+                                       dimensions, data_color_space, rotation,
+                                       flip_y, client_gpu_memory_buff);
+  if (status != 0) {
+    DLOG(ERROR) << "Failed to convert data";
+    client->OnFrameDropped(ConvertReservationFailureToFrameDropReason(
+        VideoCaptureDevice::Client::ReserveResult::kSucceeded));
+    return -1;
+  }
+  client->OnIncomingCapturedBufferExt(
+      std::move(capture_buffer),
+      VideoCaptureFormat(dimensions, capture_format.frame_rate,
+                         TARGET_PIXEL_FORMAT),
+      gfx::ColorSpace(), reference_time, timestamp, gfx::Rect(dimensions),
+      VideoFrameMetadata());
+  return status;
+}
+
+int V4L2CaptureDelegate::V4L2CaptureDelegateGpuHelper::CovertCaptureDataToNV12(
+    const uint8_t* sample,
+    size_t sample_size,
+    const VideoCaptureFormat& capture_format,
+    const gfx::Size& dimensions,
+    const gfx::ColorSpace& data_color_space,
+    int rotation,
+    bool flip_y,
+    std::unique_ptr<gfx::GpuMemoryBuffer>& client_gpu_memory_buff) {
+  const libyuv::FourCC fourcc =
+      ViedoCaptureFormatToLibyuvFourcc(capture_format);
+
+  const int crop_x = 0;
+  const int crop_y = 0;
+  const int src_width = capture_format.frame_size.width();
+  const int src_height = capture_format.frame_size.height();
+  const int crop_width = capture_format.frame_size.width() & ~1;
+  const int crop_height = capture_format.frame_size.height() & ~1;
+  int status = -1;
+
+  if (client_gpu_memory_buff && client_gpu_memory_buff->Map()) {
+    uint8_t* nv12_y_plane =
+        (uint8_t*)client_gpu_memory_buff->memory(VideoFrame::kYPlane);
+    uint8_t* nv12_uv_plane =
+        (uint8_t*)client_gpu_memory_buff->memory(VideoFrame::kUVPlane);
+    int nv12_y_stride = client_gpu_memory_buff->stride(VideoFrame::kYPlane);
+    int nv12_uv_stride = client_gpu_memory_buff->stride(VideoFrame::kUVPlane);
+    libyuv::RotationMode rotation_mode = TranslateRotation(rotation);
+    uint32_t format = libyuv::CanonicalFourCC(fourcc);
+    if (rotation_mode == libyuv::RotationMode::kRotate0 &&
+        IsNV12ConvertSupported(format)) {
+      std::vector<int32_t> strides = VideoFrame::ComputeStrides(
+          VideoPixelFormat::PIXEL_FORMAT_I420, dimensions);
+      status = FastCovertToNV12(sample, sample_size, crop_x, crop_y, src_width,
+                                src_height, crop_width, crop_height, format,
+                                nv12_y_plane, nv12_y_stride, nv12_uv_plane,
+                                nv12_uv_stride);
+    } else {
+      const size_t i420_size = VideoFrame::AllocationSize(
+          VideoPixelFormat::PIXEL_FORMAT_I420, dimensions);
+
+      i420_buffer_.reserve(i420_size);
+      if (i420_buffer_.data()) {
+        uint8_t* i420_y_plane = i420_buffer_.data();
+        uint8_t* i420_u_plane =
+            i420_y_plane +
+            VideoFrame::PlaneSize(VideoPixelFormat::PIXEL_FORMAT_I420,
+                                  VideoFrame::kYPlane, dimensions)
+                .GetArea();
+        uint8_t* i420_v_plane =
+            i420_u_plane +
+            VideoFrame::PlaneSize(VideoPixelFormat::PIXEL_FORMAT_I420,
+                                  VideoFrame::kUPlane, dimensions)
+                .GetArea();
+        std::vector<int32_t> strides = VideoFrame::ComputeStrides(
+            VideoPixelFormat::PIXEL_FORMAT_I420, dimensions);
+        const int i420_y_stride = strides[VideoFrame::kYPlane];
+        const int i420_u_stride = strides[VideoFrame::kUPlane];
+        const int i420_v_stride = strides[VideoFrame::kVPlane];
+
+        status = libyuv::ConvertToI420(
+            sample, sample_size, i420_y_plane, i420_y_stride, i420_u_plane,
+            i420_u_stride, i420_v_plane, i420_v_stride, crop_x, crop_y,
+            src_width, src_height, crop_width, crop_height, rotation_mode,
+            fourcc);
+
+        if (!status) {
+          status = libyuv::I420ToNV12(
+              i420_y_plane, i420_y_stride, i420_u_plane, i420_u_stride,
+              i420_v_plane, i420_v_stride, nv12_y_plane, nv12_y_stride,
+              nv12_uv_plane, nv12_uv_stride, src_width, src_height);
+        }
+      }
+    }
+    client_gpu_memory_buff->Unmap();
+  } else {
+    DLOG(ERROR) << "Invalid gpu memory buffer";
+  }
+
+  return status;
+}
+
+int V4L2CaptureDelegate::V4L2CaptureDelegateGpuHelper::FastCovertToNV12(
+    const uint8_t* sample,
+    size_t sample_size,
+    int crop_x,
+    int crop_y,
+    int src_width,
+    int src_height,
+    int crop_width,
+    int crop_height,
+    uint32_t format,
+    uint8_t* dst_y,
+    int dst_stride_y,
+    uint8_t* dst_uv,
+    int dst_stride_uv) {
+  int aligned_src_width = (src_width + 1) & ~1;
+  const uint8_t* src = nullptr;
+  const uint8_t* src_uv = nullptr;
+  const int abs_src_height = (src_height < 0) ? -src_height : src_height;
+  // TODO(nisse): Why allow crop_height < 0?
+  const int abs_crop_height = (crop_height < 0) ? -crop_height : crop_height;
+  int status = 0;
+  const int inv_crop_height =
+      (src_height < 0) ? -abs_crop_height : abs_crop_height;
+  if (!dst_y || !dst_uv || !sample || src_width <= 0 || crop_width <= 0 ||
+      src_height == 0 || crop_height == 0) {
+    return -1;
+  }
+
+  switch (format) {
+    case libyuv::FOURCC_YUY2:
+      src = sample + (aligned_src_width * crop_y + crop_x) * 2;
+      status = libyuv::YUY2ToNV12(src, aligned_src_width * 2, dst_y,
+                                  dst_stride_y, dst_uv, dst_stride_uv,
+                                  crop_width, inv_crop_height);
+      break;
+    case libyuv::FOURCC_MJPG:
+      status = libyuv::MJPGToNV12(sample, sample_size, dst_y, dst_stride_y,
+                                  dst_uv, dst_stride_uv, src_width,
+                                  abs_src_height, crop_width, inv_crop_height);
+      break;
+    case libyuv::FOURCC_NV12:
+      src = sample + (src_width * crop_y + crop_x);
+      src_uv = sample + (src_width * abs_src_height) +
+               ((crop_y / 2) * aligned_src_width) + ((crop_x / 2) * 2);
+      status = libyuv::NV12Copy(src, src_width, src_uv, aligned_src_width,
+                                dst_y, dst_stride_y, dst_uv, dst_stride_uv,
+                                crop_width, inv_crop_height);
+      break;
+    default:
+      status = -1;  // other fourcc - return failure code.
+  }
+
+  return status;
+}
+
+bool V4L2CaptureDelegate::V4L2CaptureDelegateGpuHelper::IsNV12ConvertSupported(
+    uint32_t fourcc) {
+  switch (fourcc) {
+    case libyuv::FOURCC_NV12:
+    case libyuv::FOURCC_YUY2:
+    case libyuv::FOURCC_MJPG:
+      return true;
+    default:
+      return false;
+  }
+}
+
+}  // namespace media
diff --git a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h
new file mode 100644
index 0000000..4f35db3
--- /dev/null
+++ b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h
@@ -0,0 +1,72 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_DELEGATE_GPU_HELPER_H_
+#define MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_DELEGATE_GPU_HELPER_H_
+
+#include <vector>
+
+#include "gpu/ipc/common/gpu_memory_buffer_support.h"
+#include "media/capture/video/linux/v4l2_capture_delegate.h"
+#include "media/capture/video/video_capture_device.h"
+
+namespace media {
+
+class V4L2CaptureDelegate ::V4L2CaptureDelegateGpuHelper {
+ public:
+  explicit V4L2CaptureDelegateGpuHelper(
+      V4L2CaptureDelegate* v4l2_capture_delegate);
+
+  V4L2CaptureDelegateGpuHelper(const V4L2CaptureDelegateGpuHelper&) = delete;
+  V4L2CaptureDelegateGpuHelper& operator=(const V4L2CaptureDelegateGpuHelper&) =
+      delete;
+
+  ~V4L2CaptureDelegateGpuHelper();
+
+ public:
+  int OnIncomingCapturedData(const uint8_t* sample,
+                             size_t sample_size,
+                             const VideoCaptureFormat& format,
+                             const gfx::ColorSpace& data_color_space,
+                             int rotation,
+                             bool flip_y,
+                             base::TimeTicks reference_time,
+                             base::TimeDelta timestamp,
+                             int frame_feedback_id = 0);
+
+ private:
+  int CovertCaptureDataToNV12(const uint8_t* sample,
+                              size_t sample_size,
+                              const VideoCaptureFormat& format,
+                              const gfx::Size& dimensions,
+                              const gfx::ColorSpace& data_color_space,
+                              int rotation,
+                              bool flip_y,
+                              std::unique_ptr<gfx::GpuMemoryBuffer>& gmb);
+
+  int FastCovertToNV12(const uint8_t* sample,
+                       size_t sample_size,
+                       int crop_x,
+                       int crop_y,
+                       int src_width,
+                       int src_height,
+                       int crop_width,
+                       int crop_height,
+                       uint32_t fourcc,
+                       uint8_t* dst_y,
+                       int dst_stride_y,
+                       uint8_t* dst_uv,
+                       int dst_stride_uv);
+
+  bool IsNV12ConvertSupported(uint32_t fourcc);
+
+ private:
+  const raw_ptr<V4L2CaptureDelegate> v4l2_delegate_;
+  gpu::GpuMemoryBufferSupport gmb_support_;
+  std::vector<uint8_t> i420_buffer_;
+};
+
+}  // namespace media
+
+#endif  // !MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_DELEGATE_GPU_HELPER_H_
diff --git a/media/capture/video/linux/v4l2_gpu_memory_buffer_factory.cc b/media/capture/video/linux/v4l2_gpu_memory_buffer_factory.cc
new file mode 100644
index 0000000..96eb79c
--- /dev/null
+++ b/media/capture/video/linux/v4l2_gpu_memory_buffer_factory.cc
@@ -0,0 +1,59 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/capture/video/linux/v4l2_gpu_memory_buffer_factory.h"
+#include "ui/gfx/client_native_pixmap_factory.h"
+#include "ui/gfx/native_pixmap.h"
+#include "ui/ozone/public/ozone_platform.h"
+
+namespace media {
+
+namespace {
+constexpr int CAPTURE_BASE_ID = 0x12345678;
+}
+
+int V4L2GpuMemoryBufferFactory::factory_id_ = 0;
+
+V4L2GpuMemoryBufferFactory::V4L2GpuMemoryBufferFactory() : buffer_id_(0) {
+  gmb_factory_ = gpu::GpuMemoryBufferFactory::CreateNativeType(nullptr);
+  client_id_ = CAPTURE_BASE_ID + factory_id_++;
+
+  ui::OzonePlatform::InitParams params;
+  params.single_process = true;
+  ui::OzonePlatform::InitializeForCapture(params);
+}
+
+V4L2GpuMemoryBufferFactory::~V4L2GpuMemoryBufferFactory() = default;
+
+std::unique_ptr<gfx::GpuMemoryBuffer>
+V4L2GpuMemoryBufferFactory::CreateGpuMemoryBuffer(const gfx::Size& size,
+                                                  gfx::BufferFormat format) {
+  gfx::BufferUsage usage = GetBufferUsage(format);
+  gfx::GpuMemoryBufferHandle handle = gmb_factory_->CreateGpuMemoryBuffer(
+      gfx::GpuMemoryBufferId(buffer_id_++), size, size, format, usage,
+      client_id_, gpu::kNullSurfaceHandle);
+
+  if (!handle.is_null()) {
+    std::unique_ptr<gfx::GpuMemoryBuffer> out_gpu_memory_buffer =
+        gmb_support_.CreateGpuMemoryBufferImplFromHandle(
+            std::move(handle), size, format, usage, base::NullCallback());
+
+    return out_gpu_memory_buffer;
+  }
+  return nullptr;
+}
+
+// static
+gfx::BufferUsage V4L2GpuMemoryBufferFactory::GetBufferUsage(
+    gfx::BufferFormat format) {
+  switch (format) {
+    case gfx::BufferFormat::YUV_420_BIPLANAR:
+      return gfx::BufferUsage::GPU_READ_CPU_READ_WRITE;
+    default:
+      // Default usage for YUV camera buffer.
+      return gfx::BufferUsage::SCANOUT_CPU_READ_WRITE;
+  }
+}
+
+}  // namespace media
diff --git a/media/capture/video/linux/v4l2_gpu_memory_buffer_factory.h b/media/capture/video/linux/v4l2_gpu_memory_buffer_factory.h
new file mode 100644
index 0000000..2af6da7
--- /dev/null
+++ b/media/capture/video/linux/v4l2_gpu_memory_buffer_factory.h
@@ -0,0 +1,41 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_CAPTURE_VIDEO_LINUX_V4L2_GPU_MEMORY_BUFFER_FACTORY_H_
+#define MEDIA_CAPTURE_VIDEO_LINUX_V4L2_GPU_MEMORY_BUFFER_FACTORY_H_
+
+#include <memory>
+#include <unordered_map>
+
+#include "gpu/ipc/common/gpu_memory_buffer_support.h"
+#include "gpu/ipc/service/gpu_memory_buffer_factory.h"
+#include "media/capture/video_capture_types.h"
+#include "ui/gfx/buffer_types.h"
+#include "ui/gfx/gpu_memory_buffer.h"
+
+namespace media {
+
+class CAPTURE_EXPORT V4L2GpuMemoryBufferFactory {
+ public:
+  explicit V4L2GpuMemoryBufferFactory();
+
+  ~V4L2GpuMemoryBufferFactory();
+
+  virtual std::unique_ptr<gfx::GpuMemoryBuffer> CreateGpuMemoryBuffer(
+      const gfx::Size& size,
+      gfx::BufferFormat format);
+
+  static gfx::BufferUsage GetBufferUsage(gfx::BufferFormat format);
+
+ private:
+  std::unique_ptr<gpu::GpuMemoryBufferFactory> gmb_factory_;
+  gpu::GpuMemoryBufferSupport gmb_support_;
+  int buffer_id_ = -1;
+  int client_id_ = -1;
+  static int factory_id_;
+};
+
+}  // namespace media
+
+#endif  // MEDIA_CAPTURE_VIDEO_LINUX_V4L2_GPU_MEMORY_BUFFER_FACTORY_H_
diff --git a/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.cc b/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.cc
index 0d61b85..507e446 100644
--- a/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.cc
+++ b/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.cc
@@ -59,7 +59,13 @@
   gfx::BufferUsage usage = GetBufferUsage(*gfx_format);
   buffer_ = gpu_buffer_manager->CreateGpuMemoryBuffer(
       dimensions, *gfx_format, usage, gpu::kNullSurfaceHandle, nullptr);
-  if (!buffer_) {
+  if (!buffer_ ||
+      buffer_->GetType() != gfx::GpuMemoryBufferType::NATIVE_PIXMAP) {
+    buffer_ = buffer_factory_.CreateGpuMemoryBuffer(dimensions, *gfx_format);
+  }
+
+  if (!buffer_ ||
+      buffer_->GetType() != gfx::GpuMemoryBufferType::NATIVE_PIXMAP) {
     DLOG(ERROR) << "Failed to create GPU memory buffer";
     return false;
   }
diff --git a/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.h b/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.h
index 05cc1d8..2ffc619 100644
--- a/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.h
+++ b/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.h
@@ -8,6 +8,7 @@
 #include <atomic>
 
 #include "media/capture/capture_export.h"
+#include "media/capture/video/linux/v4l2_gpu_memory_buffer_factory.h"
 #include "media/capture/video/linux/video_capture_gpu_memory_buffer_manager.h"
 #include "media/capture/video/video_capture_buffer_tracker.h"
 
@@ -62,6 +63,7 @@
  private:
   std::atomic_bool is_valid_{false};
   std::unique_ptr<gfx::GpuMemoryBuffer> buffer_;
+  V4L2GpuMemoryBufferFactory buffer_factory_;
   base::WeakPtrFactory<VideoCaptureGpuContextLostObserver> weak_ptr_factory_{
       this};
 };
diff --git a/media/capture/video/video_capture_buffer_pool_util.cc b/media/capture/video/video_capture_buffer_pool_util.cc
index e9c0d86..543c998 100644
--- a/media/capture/video/video_capture_buffer_pool_util.cc
+++ b/media/capture/video/video_capture_buffer_pool_util.cc
@@ -54,6 +54,10 @@
   if (switches::IsVideoCaptureUseGpuMemoryBufferEnabled()) {
     max_buffer_count = 10;
   }
+#elif BUILDFLAG(IS_LINUX)
+  if (switches::IsVideoCaptureUseGpuMemoryBufferEnabled()) {
+    max_buffer_count = 30;
+  }
 #endif
 
   return max_buffer_count;
diff --git a/ui/ozone/public/ozone_platform.cc b/ui/ozone/public/ozone_platform.cc
index 6c4ce21..17c100c 100644
--- a/ui/ozone/public/ozone_platform.cc
+++ b/ui/ozone/public/ozone_platform.cc
@@ -91,6 +91,19 @@
   g_instance->InitializeGPU(args);
 }
 
+#if BUILDFLAG(IS_LINUX)
+// static
+void OzonePlatform::InitializeForCapture(const InitParams& args) {
+  EnsureInstance();
+  if (g_instance->initialized_gpu_) {
+    return;
+  }
+  g_instance->initialized_gpu_ = true;
+  g_instance->single_process_ = args.single_process;
+  g_instance->InitializeGPU(args);
+}
+#endif
+
 // static
 OzonePlatform* OzonePlatform::GetInstance() {
   DCHECK(g_instance) << "OzonePlatform is not initialized";
diff --git a/ui/ozone/public/ozone_platform.h b/ui/ozone/public/ozone_platform.h
index b7991d9..feef2ca 100644
--- a/ui/ozone/public/ozone_platform.h
+++ b/ui/ozone/public/ozone_platform.h
@@ -241,6 +241,12 @@
   // provided by |args| as with InitalizeForUI.
   static void InitializeForGPU(const InitParams& args);
 
+#if BUILDFLAG(IS_LINUX)
+  // Initializes the subsystems for rendering but with additional properties
+  // provided by |args| as with InitializeForGPU.
+  static void InitializeForCapture(const InitParams& args);
+#endif
+
   static OzonePlatform* GetInstance();
 
   static bool IsInitialized();
