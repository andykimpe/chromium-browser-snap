From acc8db0fee233e90f4b779ba29deec4f2f24586e Mon Sep 17 00:00:00 2001
From: Yaowei Zhou <yaowei.zhou@intel.com>
Date: Wed, 15 Feb 2023 12:41:41 +0800
Subject: [PATCH] Add the zero-copy for Linux* video capture

Add the zero-copy supporting for video capture pipeline.

Bug: N/A
Change-Id: Ic9bd08a94b79731750529b35a99f700fcc815e6c
---

diff --git a/media/capture/BUILD.gn b/media/capture/BUILD.gn
index 76c9384..752ffac 100644
--- a/media/capture/BUILD.gn
+++ b/media/capture/BUILD.gn
@@ -278,6 +278,10 @@
     sources += [
       "video/linux/v4l2_capture_delegate_gpu_helper.cc",
       "video/linux/v4l2_capture_delegate_gpu_helper.h",
+      "video/linux/v4l2_external_buffer_cache.cc",
+      "video/linux/v4l2_external_buffer_cache.h",
+      "video/linux/v4l2_external_buffer_tracker.cc",
+      "video/linux/v4l2_external_buffer_tracker.h",
       "video/linux/v4l2_gpu_memory_buffer_factory.cc",
       "video/linux/v4l2_gpu_memory_buffer_factory.h",
       "video/linux/v4l2_gpu_memory_buffer_tracker.cc",
diff --git a/media/capture/video/linux/v4l2_capture_delegate.cc b/media/capture/video/linux/v4l2_capture_delegate.cc
index a72e9e3..a9bda63e 100644
--- a/media/capture/video/linux/v4l2_capture_delegate.cc
+++ b/media/capture/video/linux/v4l2_capture_delegate.cc
@@ -27,6 +27,7 @@
 #include "media/capture/mojom/image_capture_types.h"
 #include "media/capture/video/blob_utils.h"
 #include "media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h"
+#include "media/capture/video/linux/v4l2_external_buffer_cache.h"
 #include "media/capture/video/linux/video_capture_device_linux.h"
 
 using media::mojom::MeteringMode;
@@ -52,7 +53,7 @@
 // buffers by v4l2 driver can be higher or lower than this number.
 // kNumVideoBuffers should not be too small, or Chrome may not return enough
 // buffers back to driver in time.
-constexpr uint32_t kNumVideoBuffers = 4;
+constexpr uint32_t kNumVideoBuffers = 10;
 // Timeout in milliseconds v4l2_thread_ blocks waiting for a frame from the hw.
 // This value has been fine tuned. Before changing or modifying it see
 // https://crbug.com/470717
@@ -65,6 +66,11 @@
 // Typical framerate, in fps
 constexpr int kTypicalFramerate = 30;
 
+// v4l2 loopback driver name
+constexpr char kV4L2LoopbackDriver[] = {'v', '4', 'l', '2', ' ', 'l', 'o',
+                                        'o', 'p', 'b', 'a', 'c', 'k'};
+constexpr char kCardIntel[] = {'I', 'n', 't', 'e', 'l'};
+
 // V4L2 color formats supported by V4L2CaptureDelegate derived classes.
 // This list is ordered by precedence of use -- but see caveats for MJPEG.
 struct {
@@ -186,6 +192,7 @@
     DCHECK_LE(payload_size, length_);
     payload_size_ = payload_size;
   }
+  void UnMap();
 
  private:
   friend class base::RefCounted<BufferTracker>;
@@ -251,7 +258,8 @@
       is_capturing_(false),
       timeout_count_(0),
       rotation_(rotation),
-      use_gpu_buffer_(switches::IsVideoCaptureUseGpuMemoryBufferEnabled()) {
+      use_gpu_buffer_(switches::IsVideoCaptureUseGpuMemoryBufferEnabled()),
+      use_external_dma_buf_(false) {
   if (use_gpu_buffer_) {
     v4l2_gpu_helper_ = std::make_unique<V4L2CaptureDelegateGpuHelper>(this);
   }
@@ -297,6 +305,17 @@
     return;
   }
 
+  if (use_gpu_buffer_) {
+    // dynamic check v4l2 loopback driver
+    use_external_dma_buf_ = false;
+    if (0 == std::memcmp(cap.driver, kV4L2LoopbackDriver,
+                         sizeof(kV4L2LoopbackDriver)) &&
+        0 == std::memcmp(cap.card, kCardIntel, sizeof(kCardIntel))) {
+      use_external_dma_buf_ = true;
+    }
+
+    V4L2ExternalBufferCache::Instance()->Init(v4l2_);
+  }
   // Get supported video formats in preferred order. For large resolutions,
   // favour mjpeg over raw formats.
   const std::vector<uint32_t>& desired_v4l2_formats =
@@ -315,8 +334,8 @@
   }
 
   DVLOG(1) << "Chosen pixel format is " << FourccToString(*best);
-  FillV4L2Format(&video_fmt_, width, height, *best);
 
+  FillV4L2Format(&video_fmt_, width, height, *best);
   if (DoIoctl(VIDIOC_S_FMT, &video_fmt_) < 0) {
     SetErrorState(VideoCaptureError::kV4L2FailedToSetVideoCaptureFormat,
                   FROM_HERE, "Failed to set video capture format");
@@ -388,6 +407,11 @@
   TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("video_and_image_capture"),
                "V4L2CaptureDelegate::StopAndDeAllocate");
   StopStream();
+
+  if (use_gpu_buffer_) {
+    V4L2ExternalBufferCache::Instance()->Clean();
+  }
+
   // At this point we can close the device.
   // This is also needed for correctly changing settings later via VIDIOC_S_FMT.
   device_fd_.reset();
@@ -672,7 +696,11 @@
   return weak_factory_.GetWeakPtr();
 }
 
-V4L2CaptureDelegate::~V4L2CaptureDelegate() = default;
+V4L2CaptureDelegate::~V4L2CaptureDelegate() {
+  if (use_gpu_buffer_) {
+    V4L2ExternalBufferCache::Instance()->Clean();
+  }
+}
 
 bool V4L2CaptureDelegate::RunIoctl(int request, void* argp) {
   int num_retries = 0;
@@ -914,7 +942,9 @@
       return;
     }
 
-    buffer_tracker_pool_[buffer.index]->set_payload_size(buffer.bytesused);
+    if (!use_gpu_buffer_) {
+      buffer_tracker_pool_[buffer.index]->set_payload_size(buffer.bytesused);
+    }
     const scoped_refptr<BufferTracker>& buffer_tracker =
         buffer_tracker_pool_[buffer.index];
 
@@ -957,10 +987,9 @@
       // transfer = v4l2_format->fmt.pix.xfer_func;
       // See http://crbug.com/959919.
       if (use_gpu_buffer_) {
-        v4l2_gpu_helper_->OnIncomingCapturedData(
-            buffer_tracker->start(), buffer_tracker->payload_size(),
-            capture_format_, gfx::ColorSpace(), rotation_, false /* flip_y */,
-            now, timestamp);
+        DeliveryCaptureDataUseGBM(buffer, capture_format_, gfx::ColorSpace(),
+                                  rotation_, false /* flip_y */, now,
+                                  timestamp);
       } else {
         client_->OnIncomingCapturedData(
             buffer_tracker->start(), buffer_tracker->payload_size(),
@@ -980,11 +1009,12 @@
       if (blob)
         std::move(cb).Run(std::move(blob));
     }
-
-    if (DoIoctl(VIDIOC_QBUF, &buffer) < 0) {
-      SetErrorState(VideoCaptureError::kV4L2FailedToEnqueueCaptureBuffer,
-                    FROM_HERE, "Failed to enqueue capture buffer");
-      return;
+    if (!use_external_dma_buf_) {
+      if (DoIoctl(VIDIOC_QBUF, &buffer) < 0) {
+        SetErrorState(VideoCaptureError::kV4L2FailedToEnqueueCaptureBuffer,
+                      FROM_HERE, "Failed to enqueue capture buffer");
+        return;
+      }
     }
   }
 
@@ -1028,14 +1058,51 @@
   client_->OnError(error, from_here, reason);
 }
 
+void V4L2CaptureDelegate::DeliveryCaptureDataUseGBM(
+    v4l2_buffer& buffer,
+    const VideoCaptureFormat& format,
+    const gfx::ColorSpace& data_color_space,
+    int rotation,
+    bool flip_y,
+    base::TimeTicks reference_time,
+    base::TimeDelta timestamp,
+    int frame_feedback_id) {
+  struct v4l2_exportbuffer expbuf;
+  if (use_external_dma_buf_) {
+    memset(&expbuf, 0, sizeof(expbuf));
+    expbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    expbuf.index = buffer.index;
+    if (DoIoctl(VIDIOC_EXPBUF, &expbuf) || expbuf.fd <= 0) {
+      DLOG(ERROR) << "Not support dma buffer!";
+      use_external_dma_buf_ = false;
+    }
+  }
+
+  scoped_refptr<BufferTracker>& buffer_tracker =
+      buffer_tracker_pool_[buffer.index];
+
+  if (use_external_dma_buf_) {
+    if (buffer_tracker->start()) {
+      buffer_tracker->UnMap();
+    }
+    v4l2_gpu_helper_->OnIncomingCapturedExternalDmaBuf(
+        buffer.index, expbuf.fd, format, data_color_space, rotation, flip_y,
+        reference_time, timestamp, frame_feedback_id);
+
+  } else {
+    buffer_tracker->set_payload_size(buffer.bytesused);
+    v4l2_gpu_helper_->OnIncomingCapturedData(
+        buffer_tracker->start(), buffer_tracker->payload_size(), format,
+        data_color_space, rotation, flip_y, reference_time, timestamp,
+        frame_feedback_id);
+  }
+}
+
 V4L2CaptureDelegate::BufferTracker::BufferTracker(V4L2CaptureDevice* v4l2)
     : v4l2_(v4l2) {}
 
 V4L2CaptureDelegate::BufferTracker::~BufferTracker() {
-  if (!start_)
-    return;
-  const int result = v4l2_->munmap(start_, length_);
-  PLOG_IF(ERROR, result < 0) << "Error munmap()ing V4L2 buffer";
+  UnMap();
 }
 
 bool V4L2CaptureDelegate::BufferTracker::Init(int fd,
@@ -1055,4 +1122,13 @@
   return true;
 }
 
+void V4L2CaptureDelegate::BufferTracker::UnMap() {
+  if (!start_) {
+    return;
+  }
+  const int result = v4l2_->munmap(start_, length_);
+  PLOG_IF(ERROR, result < 0) << "Error munmap()ing V4L2 buffer";
+  start_ = nullptr;
+}
+
 }  // namespace media
diff --git a/media/capture/video/linux/v4l2_capture_delegate.h b/media/capture/video/linux/v4l2_capture_delegate.h
index f3cb693..a137716 100644
--- a/media/capture/video/linux/v4l2_capture_delegate.h
+++ b/media/capture/video/linux/v4l2_capture_delegate.h
@@ -114,6 +114,15 @@
                      const base::Location& from_here,
                      const std::string& reason);
 
+  void DeliveryCaptureDataUseGBM(v4l2_buffer& buffer,
+                                 const VideoCaptureFormat& format,
+                                 const gfx::ColorSpace& data_color_space,
+                                 int rotation,
+                                 bool flip_y,
+                                 base::TimeTicks reference_time,
+                                 base::TimeDelta timestamp,
+                                 int frame_feedback_id = 0);
+
   const raw_ptr<V4L2CaptureDevice> v4l2_;
   const scoped_refptr<base::SingleThreadTaskRunner> v4l2_task_runner_;
   const VideoCaptureDeviceDescriptor device_descriptor_;
@@ -142,6 +151,7 @@
   class V4L2CaptureDelegateGpuHelper;
   friend class V4L2CaptureDelegateGpuHelper;
   bool use_gpu_buffer_;
+  bool use_external_dma_buf_;
   std::unique_ptr<V4L2CaptureDelegateGpuHelper> v4l2_gpu_helper_;
 
   base::WeakPtrFactory<V4L2CaptureDelegate> weak_factory_{this};
diff --git a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.cc b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.cc
index 9c0b407..3e2dd522 100644
--- a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.cc
+++ b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.cc
@@ -4,7 +4,9 @@
 
 #include "media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h"
 
+#include "base/posix/eintr_wrapper.h"
 #include "base/trace_event/trace_event.h"
+#include "media/capture/video/linux/v4l2_external_buffer_cache.h"
 #include "third_party/libyuv/include/libyuv.h"
 #include "ui/gfx/gpu_memory_buffer.h"
 
@@ -124,6 +126,85 @@
   return status;
 }
 
+int V4L2CaptureDelegate::V4L2CaptureDelegateGpuHelper::
+    OnIncomingCapturedExternalDmaBuf(__u32 index,
+                                     int fd,
+                                     const VideoCaptureFormat& format,
+                                     const gfx::ColorSpace& data_color_space,
+                                     int rotation,
+                                     bool flip_y,
+                                     base::TimeTicks reference_time,
+                                     base::TimeDelta timestamp,
+                                     int frame_feedback_id) {
+  TRACE_EVENT0(
+      TRACE_DISABLED_BY_DEFAULT("video_and_image_capture"),
+      "V4L2CaptureDelegateGpuHelper::OnIncomingCapturedExternalDmaBuf");
+  if (!v4l2_delegate_ || !v4l2_delegate_->client_.get()) {
+    return -1;
+  }
+  VideoCaptureDevice::Client* client = v4l2_delegate_->client_.get();
+
+  auto handle_id = gfx::GpuMemoryBufferId(fd);
+  gfx::GpuMemoryBufferHandle handle =
+      V4L2ExternalBufferCache::Instance()->Find(handle_id);
+  int destination_width = format.frame_size.width() & ~1;
+  int destination_height = format.frame_size.height() & ~1;
+  if (handle.is_null()) {
+    const VideoPixelFormat pixel_format = VideoPixelFormat::PIXEL_FORMAT_NV12;
+
+    if (rotation == 90 || rotation == 270) {
+      std::swap(destination_width, destination_height);
+    }
+    const gfx::Size dimensions(destination_width, destination_height);
+    const size_t num_planes = VideoFrame::NumPlanes(pixel_format);
+    std::vector<base::ScopedFD> dmabuf_fds;
+    dmabuf_fds.push_back(base::ScopedFD(fd));
+    // TODO(crbug.com/1036174): Replace this duplication with a check.
+    // Duplicate the fd of the last plane until the number of fds are the same
+    // as the number of planes.
+    while (num_planes != dmabuf_fds.size()) {
+      int duped_fd = -1;
+      duped_fd = HANDLE_EINTR(dup(dmabuf_fds.back().get()));
+      // TODO(crbug.com/1097956): handle a failure gracefully.
+      PCHECK(duped_fd >= 0) << "Failed duplicating a dma-buf fd";
+      dmabuf_fds.emplace_back(duped_fd);
+    }
+    handle.type = gfx::NATIVE_PIXMAP;
+    handle.offset = 0;
+    handle.stride = 0;
+    handle.id = handle_id;
+
+    const int stride = dimensions.width();
+    const int nv12_y_size =
+        media::VideoFrame::PlaneSize(pixel_format, media::VideoFrame::kYPlane,
+                                     dimensions)
+            .GetArea();
+    const int nv12_uv_size =
+        media::VideoFrame::PlaneSize(pixel_format, media::VideoFrame::kUVPlane,
+                                     dimensions)
+            .GetArea();
+
+    handle.native_pixmap_handle.planes.emplace_back(stride, 0, nv12_y_size,
+                                                    std::move(dmabuf_fds[0]));
+
+    handle.native_pixmap_handle.planes.emplace_back(
+        stride, nv12_y_size, nv12_uv_size, std::move(dmabuf_fds[1]));
+  }
+  V4L2ExternalBufferCache::V4L2ExternalBufferWrapper ext_buf_wrapper(
+      v4l2_delegate_->device_fd_, index);
+
+  V4L2ExternalBufferCache::Instance()->Cache(handle.id, ext_buf_wrapper);
+
+  CapturedExternalVideoBuffer buffer(std::move(handle), format,
+                                     data_color_space);
+
+  client->OnIncomingCapturedExternalBuffer(
+      std::move(buffer), std::vector<CapturedExternalVideoBuffer>(),
+      reference_time, timestamp,
+      gfx::Rect(destination_width, destination_height));
+  return 0;
+}
+
 int V4L2CaptureDelegate::V4L2CaptureDelegateGpuHelper::CovertCaptureDataToNV12(
     const uint8_t* sample,
     size_t sample_size,
diff --git a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h
index 237fe321..bc473c1f 100644
--- a/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h
+++ b/media/capture/video/linux/v4l2_capture_delegate_gpu_helper.h
@@ -35,6 +35,16 @@
                              base::TimeDelta timestamp,
                              int frame_feedback_id = 0);
 
+  int OnIncomingCapturedExternalDmaBuf(__u32 index,
+                                       int fd,
+                                       const VideoCaptureFormat& format,
+                                       const gfx::ColorSpace& data_color_space,
+                                       int rotation,
+                                       bool flip_y,
+                                       base::TimeTicks reference_time,
+                                       base::TimeDelta timestamp,
+                                       int frame_feedback_id = 0);
+
  private:
   int CovertCaptureDataToNV12(const uint8_t* sample,
                               size_t sample_size,
diff --git a/media/capture/video/linux/v4l2_external_buffer_cache.cc b/media/capture/video/linux/v4l2_external_buffer_cache.cc
new file mode 100644
index 0000000..9c20345
--- /dev/null
+++ b/media/capture/video/linux/v4l2_external_buffer_cache.cc
@@ -0,0 +1,93 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <linux/videodev2.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+
+#include "base/logging.h"
+
+#include "media/capture/video/linux/v4l2_capture_device_impl.h"
+#include "media/capture/video/linux/v4l2_external_buffer_cache.h"
+#include "media/capture/video/linux/video_capture_device_linux.h"
+
+namespace media {
+V4L2ExternalBufferCache V4L2ExternalBufferCache::instance_;
+
+V4L2ExternalBufferCache::V4L2ExternalBufferCache() = default;
+
+V4L2ExternalBufferCache::~V4L2ExternalBufferCache() {
+  Clean();
+}
+
+void V4L2ExternalBufferCache::Init(V4L2CaptureDevice* v4l2) {
+  v4l2_ = v4l2;
+}
+gfx::GpuMemoryBufferHandle V4L2ExternalBufferCache::Find(
+    const gfx::GpuMemoryBufferId& gbm_id) {
+  base::AutoLock lock(lock_);
+
+  if (gmb_handle_map_.find(gbm_id) == gmb_handle_map_.end()) {
+    return gfx::GpuMemoryBufferHandle();
+  } else {
+    auto handle = std::move(gmb_handle_map_[gbm_id]);
+    gmb_handle_map_.erase(gbm_id);
+    return handle;
+  }
+}
+
+bool V4L2ExternalBufferCache::Cache(const gfx::GpuMemoryBufferId& gbm_id,
+                                    V4L2ExternalBufferWrapper ext_buf) {
+  base::AutoLock lock(lock_);
+  if (ext_buf_map_.find(gbm_id) != ext_buf_map_.end()) {
+    return false;
+  }
+
+  if (ext_buf.device_fd.is_valid()) {
+    ext_buf_map_.insert(std::make_pair(gbm_id, std::move(ext_buf)));
+  }
+  return true;
+}
+
+bool V4L2ExternalBufferCache::Release(gfx::GpuMemoryBufferHandle handle) {
+  base::AutoLock lock(lock_);
+  gfx::GpuMemoryBufferId& gbm_id = handle.id;
+  auto ext_buf = ext_buf_map_.find(gbm_id);
+  if (ext_buf == ext_buf_map_.end()) {
+    return false;
+  }
+
+  Release(ext_buf->second);
+  ext_buf_map_.erase(ext_buf);
+  gmb_handle_map_[gbm_id] = std::move(handle);
+  return true;
+}
+
+bool V4L2ExternalBufferCache::V4L2ExternalBufferCache::Clean() {
+  base::AutoLock lock(lock_);
+  for (auto it = ext_buf_map_.begin(); it != ext_buf_map_.end(); ++it) {
+    Release(it->second);
+  }
+  ext_buf_map_.clear();
+  return true;
+}
+
+void V4L2ExternalBufferCache::Release(V4L2ExternalBufferWrapper& ext_buf) {
+  if (ext_buf.data) {
+    munmap(ext_buf.data, ext_buf.len);
+    ext_buf.data = nullptr;
+  }
+
+  if (ext_buf.device_fd.is_valid()) {
+    struct v4l2_buffer buf = {.index = static_cast<__u32>(ext_buf.buf_index),
+                              .type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+                              .memory = V4L2_MEMORY_MMAP};
+
+    if (v4l2_->ioctl(ext_buf.device_fd.get(), VIDIOC_QBUF, &buf) < 0) {
+      LOG(ERROR) << "ioctl(VIDIOC_QBUF): error";
+      assert(0);
+    }
+  }
+}
+}  // namespace media
diff --git a/media/capture/video/linux/v4l2_external_buffer_cache.h b/media/capture/video/linux/v4l2_external_buffer_cache.h
new file mode 100644
index 0000000..9515af2a
--- /dev/null
+++ b/media/capture/video/linux/v4l2_external_buffer_cache.h
@@ -0,0 +1,65 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_CAPTURE_VIDEO_LINUX_V4L2_EXTERNAL_BUFFER_CACHE_H_
+#define MEDIA_CAPTURE_VIDEO_LINUX_V4L2_EXTERNAL_BUFFER_CACHE_H_
+
+#include <map>
+#include <memory>
+
+#include "base/files/scoped_file.h"
+#include "base/memory/ref_counted.h"
+#include "media/capture/video/linux/scoped_v4l2_device_fd.h"
+#include "media/capture/video/linux/v4l2_capture_device.h"
+#include "media/gpu/chromeos/platform_video_frame_utils.h"
+
+namespace media {
+
+class CAPTURE_EXPORT V4L2ExternalBufferCache {
+ private:
+  V4L2ExternalBufferCache();
+
+ public:
+  ~V4L2ExternalBufferCache();
+
+ public:
+  struct V4L2ExternalBufferWrapper {
+    V4L2ExternalBufferWrapper(ScopedV4L2DeviceFD& fd, size_t index)
+        : device_fd(fd), buf_index(index) {}
+    ScopedV4L2DeviceFD& device_fd;
+    size_t buf_index;
+    void* data = nullptr;
+    size_t len = 0;
+  };
+
+ public:
+  void Init(V4L2CaptureDevice* v4l2);
+  gfx::GpuMemoryBufferHandle Find(const gfx::GpuMemoryBufferId& id);
+  bool Cache(const gfx::GpuMemoryBufferId& id,
+             V4L2ExternalBufferWrapper ext_buf);
+  bool Release(gfx::GpuMemoryBufferHandle);
+  bool Clean();
+
+  static V4L2ExternalBufferCache* Instance() { return &instance_; }
+
+ private:
+  void Release(V4L2ExternalBufferWrapper&);
+
+ private:
+  static V4L2ExternalBufferCache instance_;
+
+ private:
+  V4L2CaptureDevice* v4l2_;
+
+  // Protects everything below it.
+  mutable base::Lock lock_;
+  std::map<gfx::GpuMemoryBufferId, V4L2ExternalBufferWrapper> ext_buf_map_
+      GUARDED_BY(lock_);
+  std::map<gfx::GpuMemoryBufferId, gfx::GpuMemoryBufferHandle> gmb_handle_map_
+      GUARDED_BY(lock_);
+};
+
+}  // namespace media
+
+#endif  // !MEDIA_CAPTURE_VIDEO_LINUX_V4L2_EXTERNAL_BUFFER_CACHE_H_
\ No newline at end of file
diff --git a/media/capture/video/linux/v4l2_external_buffer_tracker.cc b/media/capture/video/linux/v4l2_external_buffer_tracker.cc
new file mode 100644
index 0000000..05c77ed
--- /dev/null
+++ b/media/capture/video/linux/v4l2_external_buffer_tracker.cc
@@ -0,0 +1,73 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/capture/video/linux/v4l2_external_buffer_tracker.h"
+#include "base/posix/eintr_wrapper.h"
+#include "media/capture/video/linux/v4l2_external_buffer_cache.h"
+
+namespace media {
+
+V4L2ExternalBufferTracker::V4L2ExternalBufferTracker(
+    gfx::GpuMemoryBufferHandle handle)
+    : handle_(std::move(handle)) {}
+
+V4L2ExternalBufferTracker::~V4L2ExternalBufferTracker() {}
+
+bool V4L2ExternalBufferTracker::Init(const gfx::Size& dimensions,
+                                     VideoPixelFormat format,
+                                     const mojom::PlaneStridesPtr& strides) {
+  NOTREACHED() << "Unsupported operation";
+  return false;
+}
+
+bool V4L2ExternalBufferTracker::IsReusableForFormat(
+    const gfx::Size& dimensions,
+    VideoPixelFormat format,
+    const mojom::PlaneStridesPtr& strides) {
+  return true;
+}
+
+std::unique_ptr<VideoCaptureBufferHandle>
+V4L2ExternalBufferTracker::GetMemoryMappedAccess() {
+  NOTREACHED() << "Unsupported operation";
+  return std::make_unique<NullHandle>();
+}
+
+base::UnsafeSharedMemoryRegion
+V4L2ExternalBufferTracker::DuplicateAsUnsafeRegion() {
+  NOTREACHED() << "Unsupported operation";
+  return base::UnsafeSharedMemoryRegion();
+}
+
+mojo::ScopedSharedBufferHandle
+V4L2ExternalBufferTracker::DuplicateAsMojoBuffer() {
+  NOTREACHED() << "Unsupported operation";
+  return mojo::ScopedSharedBufferHandle();
+}
+
+gfx::GpuMemoryBufferHandle
+V4L2ExternalBufferTracker::GetGpuMemoryBufferHandle() {
+  return handle_.Clone();
+}
+
+uint32_t V4L2ExternalBufferTracker::GetMemorySizeInBytes() {
+  uint32_t size = 0;
+  for (auto& plane : handle_.native_pixmap_handle.planes) {
+    size += plane.size;
+  }
+  return size;
+}
+
+bool V4L2ExternalBufferTracker::IsSameGpuMemoryBuffer(
+    const gfx::GpuMemoryBufferHandle& handle) const {
+  return handle.id == handle_.id;
+}
+
+void V4L2ExternalBufferTracker::OnHeldByConsumersChanged(
+    bool is_held_by_consumers) {
+  if (!IsHeldByProducerOrConsumer()) {
+    V4L2ExternalBufferCache::Instance()->Release(handle_.Clone());
+  }
+}
+}  // namespace media
\ No newline at end of file
diff --git a/media/capture/video/linux/v4l2_external_buffer_tracker.h b/media/capture/video/linux/v4l2_external_buffer_tracker.h
new file mode 100644
index 0000000..eff1e07
--- /dev/null
+++ b/media/capture/video/linux/v4l2_external_buffer_tracker.h
@@ -0,0 +1,41 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_CAPTURE_VIDEO_LINUX_V4L2_EXTERNAL_BUFFER_TRACKER_H_
+#define MEDIA_CAPTURE_VIDEO_LINUX_V4L2_EXTERNAL_BUFFER_TRACKER_H_
+
+#include "media/capture/video/video_capture_buffer_tracker.h"
+
+namespace media {
+// Tracker specifics for Linux GpuMemoryBuffer.
+class CAPTURE_EXPORT V4L2ExternalBufferTracker final
+    : public VideoCaptureBufferTracker {
+ public:
+  V4L2ExternalBufferTracker(gfx::GpuMemoryBufferHandle handle);
+  ~V4L2ExternalBufferTracker() override;
+
+  // Implementation of VideoCaptureBufferTracker:
+  bool Init(const gfx::Size& dimensions,
+            VideoPixelFormat format,
+            const mojom::PlaneStridesPtr& strides) override;
+  bool IsReusableForFormat(const gfx::Size& dimensions,
+                           VideoPixelFormat format,
+                           const mojom::PlaneStridesPtr& strides) override;
+  uint32_t GetMemorySizeInBytes() override;
+  std::unique_ptr<VideoCaptureBufferHandle> GetMemoryMappedAccess() override;
+  base::UnsafeSharedMemoryRegion DuplicateAsUnsafeRegion() override;
+  mojo::ScopedSharedBufferHandle DuplicateAsMojoBuffer() override;
+  gfx::GpuMemoryBufferHandle GetGpuMemoryBufferHandle() override;
+
+  bool IsSameGpuMemoryBuffer(
+      const gfx::GpuMemoryBufferHandle& handle) const override;
+  void OnHeldByConsumersChanged(bool is_held_by_consumers) override;
+
+ private:
+  gfx::GpuMemoryBufferHandle handle_;
+};
+
+}  // namespace media
+
+#endif  // !MEDIA_CAPTURE_VIDEO_LINUX_V4L2_EXTERNAL_BUFFER_TRACKER_H_
\ No newline at end of file
diff --git a/media/capture/video/video_capture_buffer_tracker_factory_impl.cc b/media/capture/video/video_capture_buffer_tracker_factory_impl.cc
index 331336d..1530606 100644
--- a/media/capture/video/video_capture_buffer_tracker_factory_impl.cc
+++ b/media/capture/video/video_capture_buffer_tracker_factory_impl.cc
@@ -19,6 +19,7 @@
 #endif
 
 #if BUILDFLAG(IS_LINUX)
+#include "media/capture/video/linux/v4l2_external_buffer_tracker.h"
 #include "media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.h"
 #endif
 
@@ -48,6 +49,8 @@
     const gfx::GpuMemoryBufferHandle& handle) {
 #if BUILDFLAG(IS_MAC)
   return std::make_unique<GpuMemoryBufferTrackerMac>(handle.io_surface);
+#elif BUILDFLAG(IS_LINUX)
+  return std::make_unique<V4L2ExternalBufferTracker>(handle.Clone());
 #else
   return nullptr;
 #endif
