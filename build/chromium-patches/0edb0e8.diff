From 0edb0e80ae808dec4f00d7787836a3f02842f6c7 Mon Sep 17 00:00:00 2001
From: Yaowei Zhou <yaowei.zhou@intel.com>
Date: Wed, 24 Aug 2022 18:06:59 +0800
Subject: [PATCH] Add one-copy for Linux video capture

Enable the gpu memory buffer with NV12 format of Linux camera capture path for local view and video encode.

Bug: N/A
Change-Id: I3afff1c45f47e7c7141bd4bdcdf1811ea0906349
---

diff --git a/content/browser/utility_process_host.cc b/content/browser/utility_process_host.cc
index 62944e6f..3359015 100644
--- a/content/browser/utility_process_host.cc
+++ b/content/browser/utility_process_host.cc
@@ -52,7 +52,7 @@
 #include "components/os_crypt/os_crypt_switches.h"
 #endif
 
-#if BUILDFLAG(IS_WIN)
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)
 #include "media/capture/capture_switches.h"
 #endif
 
@@ -355,6 +355,13 @@
     }
 #endif  // BUILDFLAG(IS_CHROMEOS_LACROS)
 
+#if BUILDFLAG(IS_LINUX)
+    if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+            switches::kVideoCaptureUseGpuMemoryBuffer)) {
+      cmd_line->AppendSwitch(switches::kVideoCaptureUseGpuMemoryBuffer);
+    }
+#endif
+
     std::unique_ptr<UtilitySandboxedProcessLauncherDelegate> delegate =
         std::make_unique<UtilitySandboxedProcessLauncherDelegate>(
             sandbox_type_, env_, *cmd_line);
diff --git a/media/capture/BUILD.gn b/media/capture/BUILD.gn
index 3f80b62c..f7f180e 100644
--- a/media/capture/BUILD.gn
+++ b/media/capture/BUILD.gn
@@ -268,6 +268,17 @@
     ]
   }
 
+  if(is_linux) {
+    sources += [
+      "video/linux/v4l2_capture_buffer_factory.h",
+      "video/linux/v4l2_capture_buffer_factory.cc",
+      "video/linux/v4l2_gpu_memory_buffer_tracker.h",
+      "video/linux/v4l2_gpu_memory_buffer_tracker.cc",
+      "video/linux/v4l2_capture_utils.h",
+      "video/linux/v4l2_capture_utils.cc",
+    ]
+  }
+
   if (is_chromeos_ash) {
     sources += [
       "video/chromeos/camera_3a_controller.cc",
diff --git a/media/capture/video/linux/v4l2_capture_buffer_factory.cc b/media/capture/video/linux/v4l2_capture_buffer_factory.cc
new file mode 100644
index 0000000..8f02b20
--- /dev/null
+++ b/media/capture/video/linux/v4l2_capture_buffer_factory.cc
@@ -0,0 +1,61 @@
+// Copyright 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/capture/video/linux/v4l2_capture_buffer_factory.h"
+#include "ui/gfx/client_native_pixmap_factory.h"
+#include "ui/gfx/native_pixmap.h"
+#include "ui/ozone/public/ozone_platform.h"
+
+namespace media {
+
+namespace {
+constexpr int CAPTURE_BASE_ID = 0x12345678;
+}
+
+int V4L2CaptureBufferFactory::factory_id_ = 0;
+
+V4L2CaptureBufferFactory::V4L2CaptureBufferFactory() : buffer_id_(0) {
+  gmb_factory_ = gpu::GpuMemoryBufferFactory::CreateNativeType(nullptr);
+  client_id_ = CAPTURE_BASE_ID + factory_id_++;
+
+  ui::OzonePlatform::InitParams params;
+  params.single_process = true;
+  ui::OzonePlatform::InitializeForCapture(params);
+}
+
+V4L2CaptureBufferFactory::~V4L2CaptureBufferFactory() = default;
+
+std::unique_ptr<gfx::GpuMemoryBuffer>
+V4L2CaptureBufferFactory::CreateGpuMemoryBuffer(const gfx::Size& size,
+                                                gfx::BufferFormat format) {
+  gfx::BufferUsage usage = GetBufferUsage(format);
+  gfx::GpuMemoryBufferHandle handle = gmb_factory_->CreateGpuMemoryBuffer(
+      gfx::GpuMemoryBufferId(buffer_id_++), size, size, format, usage,
+      client_id_, gpu::kNullSurfaceHandle);
+
+  if (!handle.is_null()) {
+    std::unique_ptr<gfx::GpuMemoryBuffer> out_gpu_memory_buffer =
+        gmb_support_.CreateGpuMemoryBufferImplFromHandle(
+            std::move(handle), size, format, usage, base::NullCallback());
+
+    return out_gpu_memory_buffer;
+  }
+  return nullptr;
+}
+
+// static
+gfx::BufferUsage V4L2CaptureBufferFactory::GetBufferUsage(
+    gfx::BufferFormat format) {
+  switch (format) {
+    case gfx::BufferFormat::BGRX_8888:
+    case gfx::BufferFormat::YUV_420_BIPLANAR:
+      // Usage for JPEG capture buffer backed by R8 pixel buffer.
+      return gfx::BufferUsage::GPU_READ_CPU_READ_WRITE;
+    default:
+      // Default usage for YUV camera buffer.
+      return gfx::BufferUsage::SCANOUT_CPU_READ_WRITE;
+  }
+}
+
+}  // namespace media
diff --git a/media/capture/video/linux/v4l2_capture_buffer_factory.h b/media/capture/video/linux/v4l2_capture_buffer_factory.h
new file mode 100644
index 0000000..0abecd5
--- /dev/null
+++ b/media/capture/video/linux/v4l2_capture_buffer_factory.h
@@ -0,0 +1,41 @@
+// Copyright 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_BUFFER_FACTORY_H_
+#define MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_BUFFER_FACTORY_H_
+
+#include <memory>
+#include <unordered_map>
+
+#include "gpu/ipc/common/gpu_memory_buffer_support.h"
+#include "gpu/ipc/service/gpu_memory_buffer_factory.h"
+#include "media/capture/video_capture_types.h"
+#include "ui/gfx/buffer_types.h"
+#include "ui/gfx/gpu_memory_buffer.h"
+
+namespace media {
+
+class CAPTURE_EXPORT V4L2CaptureBufferFactory {
+ public:
+  explicit V4L2CaptureBufferFactory();
+
+  ~V4L2CaptureBufferFactory();
+
+  virtual std::unique_ptr<gfx::GpuMemoryBuffer> CreateGpuMemoryBuffer(
+      const gfx::Size& size,
+      gfx::BufferFormat format);
+
+  static gfx::BufferUsage GetBufferUsage(gfx::BufferFormat format);
+
+ private:
+  std::unique_ptr<gpu::GpuMemoryBufferFactory> gmb_factory_;
+  gpu::GpuMemoryBufferSupport gmb_support_;
+  int buffer_id_ = -1;
+  int client_id_ = -1;
+  static int factory_id_;
+};
+
+}  // namespace media
+
+#endif  // MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_BUFFER_FACTORY_H_
diff --git a/media/capture/video/linux/v4l2_capture_delegate.cc b/media/capture/video/linux/v4l2_capture_delegate.cc
index 7b1575de..694c42f 100644
--- a/media/capture/video/linux/v4l2_capture_delegate.cc
+++ b/media/capture/video/linux/v4l2_capture_delegate.cc
@@ -18,10 +18,15 @@
 #include "build/build_config.h"
 #include "media/base/bind_to_current_loop.h"
 #include "media/base/video_frame.h"
+#include "media/base/video_transformation.h"
 #include "media/base/video_types.h"
+#include "media/capture/capture_switches.h"
 #include "media/capture/mojom/image_capture_types.h"
 #include "media/capture/video/blob_utils.h"
+#include "media/capture/video/linux/v4l2_capture_utils.h"
 #include "media/capture/video/linux/video_capture_device_linux.h"
+#include "third_party/libyuv/include/libyuv.h"
+#include "ui/gfx/gpu_memory_buffer.h"
 
 using media::mojom::MeteringMode;
 
@@ -162,6 +167,7 @@
   return false;
 }
 
+
 }  // namespace
 
 // Class keeping track of a SPLANE V4L2 buffer, mmap()ed on construction and
@@ -244,7 +250,8 @@
       device_fd_(v4l2),
       is_capturing_(false),
       timeout_count_(0),
-      rotation_(rotation) {}
+      rotation_(rotation),
+      use_gpu_buffer_(switches::IsVideoCaptureUseGpuMemoryBufferEnabled()) {}
 
 void V4L2CaptureDelegate::AllocateAndStart(
     int width,
@@ -360,7 +367,6 @@
                                      video_fmt_.fmt.pix.height);
   capture_format_.frame_rate = frame_rate;
   capture_format_.pixel_format = pixel_format;
-
   if (!StartStream())
     return;
 
@@ -943,10 +949,17 @@
       // matrix = v4l2_format->fmt.pix.ycbcr_enc;
       // transfer = v4l2_format->fmt.pix.xfer_func;
       // See http://crbug.com/959919.
-      client_->OnIncomingCapturedData(
-          buffer_tracker->start(), buffer_tracker->payload_size(),
-          capture_format_, gfx::ColorSpace(), rotation_, false /* flip_y */,
-          now, timestamp);
+      if (use_gpu_buffer_) {
+        DeliverCaptureDataWithGBM(buffer_tracker->start(),
+                                  buffer_tracker->payload_size(),
+                                  capture_format_, gfx::ColorSpace(), rotation_,
+                                  false /* flip_y */, now, timestamp);
+      } else {
+        client_->OnIncomingCapturedData(
+            buffer_tracker->start(), buffer_tracker->payload_size(),
+            capture_format_, gfx::ColorSpace(), rotation_, false /* flip_y */,
+            now, timestamp);
+      }
     }
 
     while (!take_photo_callbacks_.empty()) {
@@ -1035,4 +1048,59 @@
   return true;
 }
 
+void V4L2CaptureDelegate::DeliverCaptureDataWithGBM(
+    const uint8_t* data,
+    int length,
+    const VideoCaptureFormat& format,
+    const gfx::ColorSpace& data_color_space,
+    int rotation,
+    bool flip_y,
+    base::TimeTicks reference_time,
+    base::TimeDelta timestamp,
+    int frame_feedback_id) {
+  VideoCaptureDevice::Client::Buffer capture_buffer;
+  constexpr int kDummyFrameFeedbackId = 0;
+  int destination_width = format.frame_size.width() & ~1;
+  int destination_height = format.frame_size.height() & ~1;
+  const VideoPixelFormat pixel_format = VideoPixelFormat::PIXEL_FORMAT_NV12;
+  const gfx::BufferFormat buff_format = gfx::BufferFormat::YUV_420_BIPLANAR;
+
+  if (rotation == 90 || rotation == 270)
+    std::swap(destination_width, destination_height);
+  const gfx::Size dimensions(destination_width, destination_height);
+
+  auto reservation_result_code = client_->ReserveOutputBuffer(
+      dimensions, pixel_format, kDummyFrameFeedbackId, &capture_buffer);
+  if (reservation_result_code !=
+      VideoCaptureDevice::Client::ReserveResult::kSucceeded) {
+    DLOG(ERROR) << "Failed to reserve output capture buffer: "
+                << (int)reservation_result_code;
+    client_->OnFrameDropped(
+        ConvertReservationFailureToFrameDropReason(reservation_result_code));
+    return;
+  }
+
+  std::unique_ptr<gfx::GpuMemoryBuffer> out_gpu_memory_buffer =
+      gmb_support_.CreateGpuMemoryBufferImplFromHandle(
+          capture_buffer.handle_provider->GetGpuMemoryBufferHandle(),
+          dimensions, buff_format, gfx::BufferUsage::GPU_READ_CPU_READ_WRITE,
+          base::NullCallback());
+
+  int status = TransferCapturedDataToGBM(data, length, format, data_color_space,
+                                         rotation, false, out_gpu_memory_buffer,
+                                         dimensions);
+
+  if (status == 0) {
+    client_->OnIncomingCapturedBufferExt(
+        std::move(capture_buffer),
+        VideoCaptureFormat(dimensions, format.frame_rate, pixel_format),
+        gfx::ColorSpace(), reference_time, timestamp, gfx::Rect(dimensions),
+        VideoFrameMetadata());
+  } else {
+    LOG(ERROR) << "Error to convert to  " << pixel_format;
+    client_->OnFrameDropped(
+        ConvertReservationFailureToFrameDropReason(reservation_result_code));
+  }
+}
+
 }  // namespace media
diff --git a/media/capture/video/linux/v4l2_capture_delegate.h b/media/capture/video/linux/v4l2_capture_delegate.h
index d0b6c41ca..e85845df 100644
--- a/media/capture/video/linux/v4l2_capture_delegate.h
+++ b/media/capture/video/linux/v4l2_capture_delegate.h
@@ -16,6 +16,7 @@
 #include "base/memory/raw_ptr.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
+#include "gpu/ipc/common/gpu_memory_buffer_support.h"
 #include "media/capture/video/linux/scoped_v4l2_device_fd.h"
 #include "media/capture/video/linux/v4l2_capture_device_impl.h"
 #include "media/capture/video/video_capture_device.h"
@@ -112,6 +113,16 @@
                      const base::Location& from_here,
                      const std::string& reason);
 
+  void DeliverCaptureDataWithGBM(const uint8_t* data,
+                                 int length,
+                                 const VideoCaptureFormat& format,
+                                 const gfx::ColorSpace& data_color_space,
+                                 int rotation,
+                                 bool flip_y,
+                                 base::TimeTicks reference_time,
+                                 base::TimeDelta timestamp,
+                                 int frame_feedback_id = 0);
+
   const raw_ptr<V4L2CaptureDevice> v4l2_;
   const scoped_refptr<base::SingleThreadTaskRunner> v4l2_task_runner_;
   const VideoCaptureDeviceDescriptor device_descriptor_;
@@ -136,6 +147,10 @@
   // Clockwise rotation in degrees. This value should be 0, 90, 180, or 270.
   int rotation_;
 
+  // support gpu buffer
+  gpu::GpuMemoryBufferSupport gmb_support_;
+  bool use_gpu_buffer_;
+
   base::WeakPtrFactory<V4L2CaptureDelegate> weak_factory_{this};
 };
 
diff --git a/media/capture/video/linux/v4l2_capture_utils.cc b/media/capture/video/linux/v4l2_capture_utils.cc
new file mode 100644
index 0000000..e2a1d90
--- /dev/null
+++ b/media/capture/video/linux/v4l2_capture_utils.cc
@@ -0,0 +1,185 @@
+// Copyright 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/capture/video/linux/v4l2_capture_utils.h"
+#include "base/logging.h"
+#include "media/base/video_frame.h"
+#include "third_party/libyuv/include/libyuv.h"
+
+namespace media {
+
+libyuv::RotationMode TranslateRotation(int rotation_degrees) {
+  DCHECK_EQ(0, rotation_degrees % 90) << " Rotation must be a multiple of 90, "
+                                         "now: "
+                                      << rotation_degrees;
+  libyuv::RotationMode rotation_mode = libyuv::kRotate0;
+  if (rotation_degrees == 90)
+    rotation_mode = libyuv::kRotate90;
+  else if (rotation_degrees == 180)
+    rotation_mode = libyuv::kRotate180;
+  else if (rotation_degrees == 270)
+    rotation_mode = libyuv::kRotate270;
+  return rotation_mode;
+}
+
+int CovertToNV12(const uint8_t* sample,
+                 size_t sample_size,
+                 uint8_t* dst_y,
+                 int dst_stride_y,
+                 uint8_t* dst_uv,
+                 int dst_stride_uv,
+                 int crop_x,
+                 int crop_y,
+                 int src_width,
+                 int src_height,
+                 int crop_width,
+                 int crop_height,
+                 uint32_t fourcc) {
+  uint32_t format = libyuv::CanonicalFourCC(fourcc);
+  int aligned_src_width = (src_width + 1) & ~1;
+  const uint8_t* src = nullptr;
+  const uint8_t* src_uv = nullptr;
+  const int abs_src_height = (src_height < 0) ? -src_height : src_height;
+  // TODO(nisse): Why allow crop_height < 0?
+  const int abs_crop_height = (crop_height < 0) ? -crop_height : crop_height;
+  int r = 0;
+  const int inv_crop_height =
+      (src_height < 0) ? -abs_crop_height : abs_crop_height;
+  if (!dst_y || !dst_uv || !sample || src_width <= 0 || crop_width <= 0 ||
+      src_height == 0 || crop_height == 0) {
+    return -1;
+  }
+
+  switch (format) {
+    case libyuv::FOURCC_YUY2:
+      src = sample + (aligned_src_width * crop_y + crop_x) * 2;
+      r = libyuv::YUY2ToNV12(src, aligned_src_width * 2, dst_y, dst_stride_y,
+                             dst_uv, dst_stride_uv, crop_width,
+                             inv_crop_height);
+      break;
+    case libyuv::FOURCC_MJPG:
+      r = libyuv::MJPGToNV12(sample, sample_size, dst_y, dst_stride_y, dst_uv,
+                             dst_stride_uv, src_width, abs_src_height,
+                             crop_width, inv_crop_height);
+      break;
+    case libyuv::FOURCC_NV12:
+      src = sample + (src_width * crop_y + crop_x);
+      src_uv = sample + (src_width * abs_src_height) +
+               ((crop_y / 2) * aligned_src_width) + ((crop_x / 2) * 2);
+      r = libyuv::NV12Copy(src, src_width, src_uv, aligned_src_width, dst_y,
+                           dst_stride_y, dst_uv, dst_stride_uv, crop_width,
+                           inv_crop_height);
+      break;
+    default:
+      r = -1;  // unknown fourcc - return failure code.
+  }
+
+  return r;
+}
+
+libyuv::FourCC ViedoCaptureFormatToLibyuvFourcc(
+    const VideoCaptureFormat& format) {
+  const int chopped_width = format.frame_size.width() & 1;
+  const int chopped_height = format.frame_size.height() & 1;
+
+  switch (format.pixel_format) {
+    case PIXEL_FORMAT_NV12:
+      DCHECK(!chopped_width && !chopped_height);
+      return libyuv::FOURCC_NV12;
+    case PIXEL_FORMAT_YUY2:
+      DCHECK(!chopped_width && !chopped_height);
+      return libyuv::FOURCC_YUY2;
+    case PIXEL_FORMAT_MJPEG:
+      return libyuv::FOURCC_MJPG;
+    default:
+      NOTREACHED();
+  }
+  return libyuv::FOURCC_ANY;
+}
+
+bool IsNV12ConvertSupported(const VideoPixelFormat& format) {
+  switch (format) {
+    case VideoPixelFormat::PIXEL_FORMAT_NV12:
+    case VideoPixelFormat::PIXEL_FORMAT_YUY2:
+    case VideoPixelFormat::PIXEL_FORMAT_MJPEG:
+      return true;
+    default:
+      return false;
+  }
+}
+
+int TransferCapturedDataToGBM(const uint8_t* data,
+                              int length,
+                              const VideoCaptureFormat& format,
+                              const gfx::ColorSpace& data_color_space,
+                              int rotation,
+                              bool flip_y,
+                              std::unique_ptr<gfx::GpuMemoryBuffer>& gmb,
+                              const gfx::Size& dimensions) {
+  const libyuv::FourCC fourcc_format = ViedoCaptureFormatToLibyuvFourcc(format);
+  const VideoPixelFormat pixel_format = VideoPixelFormat::PIXEL_FORMAT_NV12;
+
+  const int crop_x = 0;
+  const int crop_y = 0;
+  const int src_width = format.frame_size.width();
+  const int src_height = format.frame_size.height();
+  const int crop_width = format.frame_size.width() & ~1;
+  const int crop_height = format.frame_size.height() & ~1;
+  int status = -1;
+
+  if (gmb && gmb->Map()) {
+    uint8_t* nv12_y = (uint8_t*)gmb->memory(0);
+    uint8_t* nv12_uv = (uint8_t*)gmb->memory(1);
+    int nv12_y_plane_stride = gmb->stride(0);
+    int nv12_uv_plane_stride = gmb->stride(1);
+    libyuv::RotationMode rotation_mode = TranslateRotation(rotation);
+    if (rotation_mode == libyuv::RotationMode::kRotate0
+    &&IsNV12ConvertSupported(format.pixel_format)) {
+      status = CovertToNV12(data, length, nv12_y, nv12_y_plane_stride, nv12_uv,
+                            nv12_uv_plane_stride, crop_x, crop_y, src_width,
+                            src_height, crop_width, crop_height, fourcc_format);
+    } else {
+      const size_t i420_size = VideoFrame::AllocationSize(
+          VideoPixelFormat::PIXEL_FORMAT_I420, dimensions);
+      std::vector<uint8_t> i420_buffer;
+      i420_buffer.reserve(i420_size);
+
+      if (i420_buffer.data()) {
+        uint8_t* i420_y_data = i420_buffer.data();
+        uint8_t* i420_u_data =
+            i420_y_data +
+            media::VideoFrame::PlaneSize(VideoPixelFormat::PIXEL_FORMAT_I420,
+                                         media::VideoFrame::kYPlane, dimensions)
+                .GetArea();
+        uint8_t* i420_v_data =
+            i420_u_data +
+            media::VideoFrame::PlaneSize(VideoPixelFormat::PIXEL_FORMAT_I420,
+                                         media::VideoFrame::kUPlane, dimensions)
+                .GetArea();
+        const int i420_y_stride = dimensions.width();
+        const int i420_uv_stride = i420_y_stride / 2;
+
+        status = libyuv::ConvertToI420(
+            data, length, i420_y_data, i420_y_stride, i420_u_data,
+            i420_uv_stride, i420_v_data, i420_uv_stride, crop_x, crop_y,
+            src_width, src_height, crop_width, crop_height, rotation_mode,
+            fourcc_format);
+
+        if (!status) {
+          status = libyuv::I420ToNV12(
+              i420_y_data, i420_y_stride, i420_u_data, i420_uv_stride,
+              i420_v_data, i420_uv_stride, nv12_y, nv12_y_plane_stride, nv12_uv,
+              nv12_uv_plane_stride, src_width, src_height);
+        }
+      }
+    }
+    gmb->Unmap();
+  } else {
+    DLOG(ERROR) << "Error to convert to  " << pixel_format;
+  }
+
+  return status;
+}
+
+}  // namespace media
\ No newline at end of file
diff --git a/media/capture/video/linux/v4l2_capture_utils.h b/media/capture/video/linux/v4l2_capture_utils.h
new file mode 100644
index 0000000..4fc7759
--- /dev/null
+++ b/media/capture/video/linux/v4l2_capture_utils.h
@@ -0,0 +1,22 @@
+// Copyright 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_UTILS_H_
+#define MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_UTILS_H_
+#include "media/base/video_types.h"
+#include "ui/gfx/gpu_memory_buffer.h"
+#include "media/capture/video_capture_types.h"
+
+namespace media {
+
+int TransferCapturedDataToGBM(const uint8_t* data,
+                              int length,
+                              const VideoCaptureFormat& format,
+                              const gfx::ColorSpace& data_color_space,
+                              int rotation,
+                              bool flip_y,
+                              std::unique_ptr<gfx::GpuMemoryBuffer>& gmb,
+                              const gfx::Size& dimensions);
+} // namespace media
+#endif // !MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_UTILS_H_
\ No newline at end of file
diff --git a/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.cc b/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.cc
new file mode 100644
index 0000000..cbbff74
--- /dev/null
+++ b/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.cc
@@ -0,0 +1,99 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.h"
+#include "media/capture/video/video_capture_buffer_handle.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+#include "ui/gfx/geometry/size.h"
+
+namespace media {
+
+// Converts the video pixel format |pixel_format| to gfx::BufferFormat.
+absl::optional<gfx::BufferFormat> PixFormatVideoToGfx(
+    VideoPixelFormat pixel_format) {
+  switch (pixel_format) {
+    case PIXEL_FORMAT_MJPEG:
+      return gfx::BufferFormat::R_8;
+    case PIXEL_FORMAT_XRGB:
+      return gfx::BufferFormat::BGRX_8888;
+    case PIXEL_FORMAT_NV12:
+      return gfx::BufferFormat::YUV_420_BIPLANAR;
+    default:
+      return absl::nullopt;
+  }
+}
+
+V4L2GpuMemoryBufferTracker::V4L2GpuMemoryBufferTracker() = default;
+
+V4L2GpuMemoryBufferTracker::~V4L2GpuMemoryBufferTracker() = default;
+
+bool V4L2GpuMemoryBufferTracker::Init(const gfx::Size& dimensions,
+                                      VideoPixelFormat format,
+                                      const mojom::PlaneStridesPtr& strides) {
+  absl::optional<gfx::BufferFormat> gfx_format = PixFormatVideoToGfx(format);
+  if (!gfx_format) {
+    NOTREACHED() << "Unsupported VideoPixelFormat "
+                 << VideoPixelFormatToString(format);
+    return false;
+  }
+  buffer_ = buffer_factory_.CreateGpuMemoryBuffer(dimensions, *gfx_format);
+  if (!buffer_) {
+    NOTREACHED() << "Failed to create GPU memory buffer";
+    return false;
+  }
+  return true;
+}
+
+bool V4L2GpuMemoryBufferTracker::IsReusableForFormat(
+    const gfx::Size& dimensions,
+    VideoPixelFormat format,
+    const mojom::PlaneStridesPtr& strides) {
+  absl::optional<gfx::BufferFormat> gfx_format = PixFormatVideoToGfx(format);
+  if (!gfx_format) {
+    return false;
+  }
+  return (*gfx_format == buffer_->GetFormat() &&
+          dimensions == buffer_->GetSize());
+}
+
+std::unique_ptr<VideoCaptureBufferHandle>
+V4L2GpuMemoryBufferTracker::GetMemoryMappedAccess() {
+  NOTREACHED() << "Unsupported operation";
+  return std::make_unique<NullHandle>();
+}
+
+base::UnsafeSharedMemoryRegion
+V4L2GpuMemoryBufferTracker::DuplicateAsUnsafeRegion() {
+  NOTREACHED() << "Unsupported operation";
+  return base::UnsafeSharedMemoryRegion();
+}
+
+mojo::ScopedSharedBufferHandle
+V4L2GpuMemoryBufferTracker::DuplicateAsMojoBuffer() {
+  NOTREACHED() << "Unsupported operation";
+  return mojo::ScopedSharedBufferHandle();
+}
+
+gfx::GpuMemoryBufferHandle
+V4L2GpuMemoryBufferTracker::GetGpuMemoryBufferHandle() {
+  DCHECK(buffer_);
+  return buffer_->CloneHandle();
+}
+
+uint32_t V4L2GpuMemoryBufferTracker::GetMemorySizeInBytes() {
+  DCHECK(buffer_);
+  switch (buffer_->GetFormat()) {
+    case gfx::BufferFormat::YUV_420_BIPLANAR:
+      return buffer_->GetSize().width() * buffer_->GetSize().height() * 3 / 2;
+    case gfx::BufferFormat::R_8:
+      return buffer_->GetSize().width() * buffer_->GetSize().height();
+    case gfx::BufferFormat::BGRX_8888:
+      return buffer_->GetSize().width() * buffer_->GetSize().height() * 4;
+    default:
+      NOTREACHED() << "Unsupported gfx buffer format";
+      return buffer_->GetSize().width() * buffer_->GetSize().height();
+  }
+}
+
+}  // namespace media
diff --git a/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.h b/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.h
new file mode 100644
index 0000000..72bb2ca
--- /dev/null
+++ b/media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.h
@@ -0,0 +1,41 @@
+// Copyright 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_CAPTURE_VIDEO_LINUX_V4L2_GPU_MEMORY_BUFFER_TRACKER_H_
+#define MEDIA_CAPTURE_VIDEO_LINUX_V4L2_GPU_MEMORY_BUFFER_TRACKER_H_
+
+#include "media/capture/video/linux/v4l2_capture_buffer_factory.h"
+#include "media/capture/video/video_capture_buffer_tracker.h"
+
+namespace media {
+
+// Tracker specifics for Linux GpuMemoryBuffer.
+class CAPTURE_EXPORT V4L2GpuMemoryBufferTracker final
+    : public VideoCaptureBufferTracker {
+ public:
+  V4L2GpuMemoryBufferTracker();
+  ~V4L2GpuMemoryBufferTracker() override;
+
+  // Implementation of VideoCaptureBufferTracker:
+  bool Init(const gfx::Size& dimensions,
+            VideoPixelFormat format,
+            const mojom::PlaneStridesPtr& strides) override;
+  bool IsReusableForFormat(const gfx::Size& dimensions,
+                           VideoPixelFormat format,
+                           const mojom::PlaneStridesPtr& strides) override;
+  uint32_t GetMemorySizeInBytes() override;
+  std::unique_ptr<VideoCaptureBufferHandle> GetMemoryMappedAccess() override;
+  base::UnsafeSharedMemoryRegion DuplicateAsUnsafeRegion() override;
+  mojo::ScopedSharedBufferHandle DuplicateAsMojoBuffer() override;
+  gfx::GpuMemoryBufferHandle GetGpuMemoryBufferHandle() override;
+
+ private:
+  V4L2CaptureBufferFactory buffer_factory_;
+  std::unique_ptr<gfx::GpuMemoryBuffer> buffer_;
+  base::UnsafeSharedMemoryRegion region_;
+};
+
+}  // namespace media
+
+#endif  // MEDIA_CAPTURE_VIDEO_LINUX_V4L2_GPU_MEMORY_BUFFER_TRACKER_H_
\ No newline at end of file
diff --git a/media/capture/video/video_capture_buffer_pool_util.cc b/media/capture/video/video_capture_buffer_pool_util.cc
index 26363105..45cad5a 100644
--- a/media/capture/video/video_capture_buffer_pool_util.cc
+++ b/media/capture/video/video_capture_buffer_pool_util.cc
@@ -48,6 +48,10 @@
   if (switches::IsVideoCaptureUseGpuMemoryBufferEnabled()) {
     max_buffer_count = 30;
   }
+#elif BUILDFLAG(IS_LINUX)
+  if (switches::IsVideoCaptureUseGpuMemoryBufferEnabled()) {
+    max_buffer_count = 30;
+  }
 #endif
 
   return max_buffer_count;
diff --git a/media/capture/video/video_capture_buffer_tracker_factory_impl.cc b/media/capture/video/video_capture_buffer_tracker_factory_impl.cc
index 963b6e6..79b56d1b 100644
--- a/media/capture/video/video_capture_buffer_tracker_factory_impl.cc
+++ b/media/capture/video/video_capture_buffer_tracker_factory_impl.cc
@@ -18,6 +18,10 @@
 #include "media/capture/video/mac/gpu_memory_buffer_tracker_mac.h"
 #endif
 
+#if BUILDFLAG(IS_LINUX)
+#include "media/capture/video/linux/v4l2_gpu_memory_buffer_tracker.h"
+#endif
+
 namespace media {
 
 std::unique_ptr<VideoCaptureBufferTracker>
@@ -29,6 +33,8 @@
       return std::make_unique<GpuMemoryBufferTracker>();
 #elif BUILDFLAG(IS_MAC)
       return std::make_unique<GpuMemoryBufferTrackerMac>();
+#elif BUILDFLAG(IS_LINUX)
+      return std::make_unique<V4L2GpuMemoryBufferTracker>();
 #else
       return nullptr;
 #endif
diff --git a/third_party/blink/renderer/platform/video_capture/video_capture_impl.cc b/third_party/blink/renderer/platform/video_capture/video_capture_impl.cc
index 45360c8..51b5c3f0 100644
--- a/third_party/blink/renderer/platform/video_capture/video_capture_impl.cc
+++ b/third_party/blink/renderer/platform/video_capture/video_capture_impl.cc
@@ -540,6 +540,12 @@
   texture_target = GL_TEXTURE_EXTERNAL_OES;
 #endif  // BUILDFLAG(IS_WIN)
 
+#if BUILDFLAG(IS_LINUX)
+  // Explicitly set GL_TEXTURE_EXTERNAL_OES since ImageTextureTarget() will
+  // return GL_TEXTURE_2D due to GMB factory not supporting NV12 GMBs.
+  if (frame_info_->pixel_format == media::PIXEL_FORMAT_NV12)
+    texture_target = GL_TEXTURE_EXTERNAL_OES;
+#endif
   // TODO(sunnyps): Get rid of NV12_DUAL_GMB format and instead rely on enabled
   // by default multi plane shared images on Windows.
 
diff --git a/ui/ozone/public/ozone_platform.cc b/ui/ozone/public/ozone_platform.cc
index 30fcf86d..011ea04b 100644
--- a/ui/ozone/public/ozone_platform.cc
+++ b/ui/ozone/public/ozone_platform.cc
@@ -90,6 +90,18 @@
   g_instance->InitializeGPU(args);
 }
 
+#if BUILDFLAG(IS_LINUX)
+// static
+void OzonePlatform::InitializeForCapture(const InitParams& args) {
+ EnsureInstance();
+  if (g_instance->initialized_gpu_)
+    return;
+  g_instance->initialized_gpu_ = true;
+  g_instance->single_process_ = args.single_process;
+  g_instance->InitializeGPU(args);
+}
+#endif
+
 // static
 OzonePlatform* OzonePlatform::GetInstance() {
   DCHECK(g_instance) << "OzonePlatform is not initialized";
diff --git a/ui/ozone/public/ozone_platform.h b/ui/ozone/public/ozone_platform.h
index df6b551..ba30135 100644
--- a/ui/ozone/public/ozone_platform.h
+++ b/ui/ozone/public/ozone_platform.h
@@ -238,6 +238,12 @@
   // provided by |args| as with InitalizeForUI.
   static void InitializeForGPU(const InitParams& args);
 
+#if BUILDFLAG(IS_LINUX)
+  // Initializes the subsystems for rendering but with additional properties
+  // provided by |args| as with InitializeForGPU.
+  static void InitializeForCapture(const InitParams& args);
+#endif
+
   static OzonePlatform* GetInstance();
 
   static bool IsInitialized();
