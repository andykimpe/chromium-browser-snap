From fe38fdb19778e6e472a156c6aa63fe494e803f4d Mon Sep 17 00:00:00 2001
From: Yaowei Zhou <yaowei.zhou@intel.com>
Date: Thu, 02 Feb 2023 14:22:34 +0800
Subject: [PATCH] Dynamic fallback to system memory when failed to allocate NV12 GPU memory buffer

Bug: N/A
Change-Id: I8ba75b3981ebb890662d2a3b3981c0578d0f6ec7
---

diff --git a/content/browser/gpu/gpu_memory_buffer_manager_singleton.cc b/content/browser/gpu/gpu_memory_buffer_manager_singleton.cc
index 668fcf8..5aa1fa7c 100644
--- a/content/browser/gpu/gpu_memory_buffer_manager_singleton.cc
+++ b/content/browser/gpu/gpu_memory_buffer_manager_singleton.cc
@@ -21,6 +21,10 @@
 #include "ui/accelerated_widget_mac/window_resize_helper_mac.h"
 #endif
 
+#if BUILDFLAG(IS_LINUX)
+#include "media/capture/capture_switches.h"
+#endif
+
 namespace content {
 namespace {
 
@@ -52,6 +56,23 @@
 #endif
 }
 
+#if BUILDFLAG(IS_LINUX)
+// Dynamic check NV12 format support as supported format inconsistent in
+// system and chromium miniGBM
+void DynamicUpdateVideoCaptureUseGpuMemoryBuffer(bool support_nv12) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableVideoCaptureUseGpuMemoryBuffer) ||
+      !base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kVideoCaptureUseGpuMemoryBuffer)) {
+    return;
+  }
+
+  if (!support_nv12) {
+    base::CommandLine::ForCurrentProcess()->AppendSwitch(
+        switches::kDisableVideoCaptureUseGpuMemoryBuffer);
+  }
+}
+#endif  // BUILDFLAG(IS_LINUX)
 }  // namespace
 
 GpuMemoryBufferManagerSingleton::GpuMemoryBufferManagerSingleton(int client_id)
@@ -79,6 +100,12 @@
 }
 
 void GpuMemoryBufferManagerSingleton::OnGpuExtraInfoUpdate() {
+#if BUILDFLAG(IS_LINUX) && \
+    (BUILDFLAG(OZONE_PLATFORM_X11) || BUILDFLAG(OZONE_PLATFORM_WAYLAND))
+  DynamicUpdateVideoCaptureUseGpuMemoryBuffer(
+      gpu_data_manager_impl_->GetGpuExtraInfo().gpu_memory_buffer_support_NV12);
+#endif
+
 #if defined(USE_OZONE_PLATFORM_X11)
   // X11 fetches buffer formats on gpu and passes them via gpu extra info.
   if (!ShouldSetBufferFormatsFromGpuExtraInfo())
diff --git a/ui/gfx/gpu_extra_info.h b/ui/gfx/gpu_extra_info.h
index e8fa594..d1edbfea 100644
--- a/ui/gfx/gpu_extra_info.h
+++ b/ui/gfx/gpu_extra_info.h
@@ -65,6 +65,10 @@
 #if defined(USE_OZONE_PLATFORM_X11)
   std::vector<gfx::BufferUsageAndFormat> gpu_memory_buffer_support_x11;
 #endif
+#if BUILDFLAG(IS_LINUX) && \
+    (BUILDFLAG(OZONE_PLATFORM_X11) || BUILDFLAG(OZONE_PLATFORM_WAYLAND))
+  bool gpu_memory_buffer_support_NV12;
+#endif
 };
 
 }  // namespace gfx
diff --git a/ui/gfx/mojom/BUILD.gn b/ui/gfx/mojom/BUILD.gn
index 055d205..0fec929 100644
--- a/ui/gfx/mojom/BUILD.gn
+++ b/ui/gfx/mojom/BUILD.gn
@@ -49,7 +49,9 @@
   if (ozone_platform_x11) {
     enabled_features += [ "enable_x11_params" ]
   }
-
+  if (is_linux && (ozone_platform_x11 || ozone_platform_wayland)) {
+    enabled_features += [ "enable_nv12_params" ]
+  }
   shared_cpp_typemaps = [
     {
       types = [
diff --git a/ui/gfx/mojom/gpu_extra_info.mojom b/ui/gfx/mojom/gpu_extra_info.mojom
index 3de1c579..6d724c2b 100644
--- a/ui/gfx/mojom/gpu_extra_info.mojom
+++ b/ui/gfx/mojom/gpu_extra_info.mojom
@@ -24,4 +24,7 @@
 
   [EnableIf=enable_x11_params]
   array<gfx.mojom.BufferUsageAndFormat> gpu_memory_buffer_support_x11;
+
+  [EnableIf=enable_nv12_params]
+  bool gpu_memory_buffer_support_NV12;
 };
diff --git a/ui/gfx/mojom/gpu_extra_info_mojom_traits.cc b/ui/gfx/mojom/gpu_extra_info_mojom_traits.cc
index 15c7340..9add661 100644
--- a/ui/gfx/mojom/gpu_extra_info_mojom_traits.cc
+++ b/ui/gfx/mojom/gpu_extra_info_mojom_traits.cc
@@ -28,6 +28,10 @@
   if (!data.ReadGpuMemoryBufferSupportX11(&out->gpu_memory_buffer_support_x11))
     return false;
 #endif
+#if BUILDFLAG(IS_LINUX) && \
+    (BUILDFLAG(OZONE_PLATFORM_X11) || BUILDFLAG(OZONE_PLATFORM_WAYLAND))
+  out->gpu_memory_buffer_support_NV12 = data.gpu_memory_buffer_support_NV12();
+#endif
   return true;
 }
 
diff --git a/ui/gfx/mojom/gpu_extra_info_mojom_traits.h b/ui/gfx/mojom/gpu_extra_info_mojom_traits.h
index 12b616f..7c908bf0 100644
--- a/ui/gfx/mojom/gpu_extra_info_mojom_traits.h
+++ b/ui/gfx/mojom/gpu_extra_info_mojom_traits.h
@@ -68,6 +68,12 @@
     return input.gpu_memory_buffer_support_x11;
   }
 #endif
+#if BUILDFLAG(IS_LINUX) && \
+    (BUILDFLAG(OZONE_PLATFORM_X11) || BUILDFLAG(OZONE_PLATFORM_WAYLAND))
+  static bool gpu_memory_buffer_support_NV12(const gfx::GpuExtraInfo& input) {
+    return input.gpu_memory_buffer_support_NV12;
+  }
+#endif
 };
 
 }  // namespace mojo
diff --git a/ui/ozone/platform/wayland/gpu/wayland_gl_egl_utility.cc b/ui/ozone/platform/wayland/gpu/wayland_gl_egl_utility.cc
index b3e92d8..ee165fe 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_gl_egl_utility.cc
+++ b/ui/ozone/platform/wayland/gpu/wayland_gl_egl_utility.cc
@@ -5,6 +5,11 @@
 #include "ui/ozone/platform/wayland/gpu/wayland_gl_egl_utility.h"
 
 #include "base/containers/contains.h"
+#if BUILDFLAG(IS_LINUX)
+#include "ui/gfx/native_pixmap.h"
+#include "ui/ozone/public/ozone_platform.h"
+#include "ui/ozone/public/surface_factory_ozone.h"
+#endif  // BUILDFLAG(IS_LINUX)
 
 // From ANGLE's egl/eglext.h. Follows the same approach as in
 // ui/gl/gl_surface_egl.cc
@@ -74,7 +79,23 @@
 
 void WaylandGLEGLUtility::CollectGpuExtraInfo(
     bool enable_native_gpu_memory_buffers,
-    gfx::GpuExtraInfo& gpu_extra_info) const {}
+    gfx::GpuExtraInfo& gpu_extra_info) const {
+#if BUILDFLAG(IS_LINUX)
+  if (!enable_native_gpu_memory_buffers) {
+    gpu_extra_info.gpu_memory_buffer_support_NV12 = false;
+    return;
+  }
+  scoped_refptr<gfx::NativePixmap> pixmap;
+  pixmap = ui::OzonePlatform::GetInstance()
+               ->GetSurfaceFactoryOzone()
+               ->CreateNativePixmap(gfx::kNullAcceleratedWidget, nullptr,
+                                    gfx::Size(2, 2),
+                                    gfx::BufferFormat::YUV_420_BIPLANAR,
+                                    gfx::BufferUsage::GPU_READ_CPU_READ_WRITE);
+
+  gpu_extra_info.gpu_memory_buffer_support_NV12 = !!pixmap;
+#endif  // BUILDFLAG(IS_LINUX)
+}
 
 bool WaylandGLEGLUtility::X11DoesVisualHaveAlphaForTest() const {
   return false;
diff --git a/ui/ozone/platform/x11/gl_egl_utility_x11.cc b/ui/ozone/platform/x11/gl_egl_utility_x11.cc
index 58c7fe6..0eb5608 100644
--- a/ui/ozone/platform/x11/gl_egl_utility_x11.cc
+++ b/ui/ozone/platform/x11/gl_egl_utility_x11.cc
@@ -12,6 +12,10 @@
 #include "ui/gl/gl_implementation.h"
 #include "ui/gl/gl_utils.h"
 
+#if BUILDFLAG(IS_LINUX)
+#include "base/ranges/algorithm.h"
+#endif
+
 namespace ui {
 
 GLEGLUtilityX11::GLEGLUtilityX11() = default;
@@ -45,6 +49,14 @@
     // ANGLE does not yet support EGL_EXT_image_dma_buf_import[_modifiers].
     gpu_extra_info.gpu_memory_buffer_support_x11.clear();
   }
+#if BUILDFLAG(IS_LINUX)
+  gpu_extra_info.gpu_memory_buffer_support_NV12 = base::ranges::any_of(
+      ui::GpuMemoryBufferSupportX11::GetInstance()->supported_configs(),
+      [](gfx::BufferUsageAndFormat other) {
+        return other.format == gfx::BufferFormat::YUV_420_BIPLANAR &&
+               other.usage == gfx::BufferUsage::GPU_READ_CPU_READ_WRITE;
+      });
+#endif
 }
 
 bool GLEGLUtilityX11::X11DoesVisualHaveAlphaForTest() const {
