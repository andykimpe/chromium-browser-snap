From 9bc26a79377b2b07e626beaf0dd2532dad1231bd Mon Sep 17 00:00:00 2001
From: Xuanxi Leng <xuanxi.leng@intel.com>
Date: Thu, 20 Oct 2022 02:01:29 +0000
Subject: [PATCH] Linux/VA-API: Set 'RGBX_8888' usage as 'GPU_READ' for VDA

This CL fixes VDA failure with Chromium minigbm on Linux.
The 'VaapiVideoDecodeAccelerator' requires the VPP to download the
decoded frame from the internal surface to the allocated native pixmap.
'SCANOUT_VDA_WRITE' is used for 'YUV_420_BIPLANAR' on ChromeOS; For
Linux, the usage is set to 'GPU_READ' for 'RGBX_8888'.

Bug: 1338827
Change-Id: I0d623b27503e64837a82a254a88a6c58e693e568
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3757114
Commit-Queue: Andres Calderon Jaramillo <andrescj@chromium.org>
Reviewed-by: Andres Calderon Jaramillo <andrescj@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1061367}
---

diff --git a/media/gpu/vaapi/vaapi_picture_native_pixmap_ozone.cc b/media/gpu/vaapi/vaapi_picture_native_pixmap_ozone.cc
index 5437b2f..08f8fb6 100644
--- a/media/gpu/vaapi/vaapi_picture_native_pixmap_ozone.cc
+++ b/media/gpu/vaapi/vaapi_picture_native_pixmap_ozone.cc
@@ -108,9 +108,18 @@
 
   ui::OzonePlatform* platform = ui::OzonePlatform::GetInstance();
   ui::SurfaceFactoryOzone* factory = platform->GetSurfaceFactoryOzone();
+  gfx::BufferUsage buffer_usage = gfx::BufferUsage::SCANOUT_VDA_WRITE;
+#if BUILDFLAG(USE_VAAPI_X11)
+  // The 'VaapiVideoDecodeAccelerator' requires the VPP to download the decoded
+  // frame from the internal surface to the allocated native pixmap.
+  // 'SCANOUT_VDA_WRITE' is used for 'YUV_420_BIPLANAR' on ChromeOS; For Linux,
+  // the usage is set to 'GPU_READ' for 'RGBX_8888'.
+  DCHECK(format == gfx::BufferFormat::RGBX_8888);
+  buffer_usage = gfx::BufferUsage::GPU_READ;
+#endif
   auto pixmap = factory->CreateNativePixmap(
-      gfx::kNullAcceleratedWidget, VK_NULL_HANDLE, size_, format,
-      gfx::BufferUsage::SCANOUT_VDA_WRITE, /*framebuffer_size=*/visible_size_);
+      gfx::kNullAcceleratedWidget, VK_NULL_HANDLE, size_, format, buffer_usage,
+      /*framebuffer_size=*/visible_size_);
   if (!pixmap) {
     return VaapiStatus::Codes::kNoPixmap;
   }
